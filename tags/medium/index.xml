<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>medium on Yang&#39;s Blog</title>
    <link>https://ericliu03.github.io/tags/medium/</link>
    <description>Recent content in medium on Yang&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 09 Oct 2019 11:27:59 -0700</lastBuildDate>
    
	<atom:link href="https://ericliu03.github.io/tags/medium/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Leetcode 735] Asteroid Collision</title>
      <link>https://ericliu03.github.io/posts/2019/10/lc_735_asteroid_collision/</link>
      <pubDate>Wed, 09 Oct 2019 11:27:59 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/10/lc_735_asteroid_collision/</guid>
      <description>Question Leetcode 735: Asteroid Collision
We are given an array asteroids of integers representing asteroids in a row.
For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.
Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode.</description>
    </item>
    
    <item>
      <title>[Leetcode 334] Increasing Triplet Subsequence</title>
      <link>https://ericliu03.github.io/posts/2019/10/lc_334_increasing_triplet_sbsequence/</link>
      <pubDate>Thu, 03 Oct 2019 11:25:01 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/10/lc_334_increasing_triplet_sbsequence/</guid>
      <description>Question Leetcode 334: Increasing Triplet Subsequence
Given an unsorted array return whether an increasing subsequence of length 3 exists or not in the array.
Formally the function should:
Return true if there exists i, j, k such that arr[i] &amp;lt; arr[j] &amp;lt; arr[k] given 0 ≤ i &amp;lt; j &amp;lt; k ≤ n-1 else return false.  Note:  Your algorithm should run in O(n) time complexity and O(1) space complexity.</description>
    </item>
    
    <item>
      <title>[Leetcode 370] Range Addition</title>
      <link>https://ericliu03.github.io/posts/2019/09/lc_370_range_addition/</link>
      <pubDate>Thu, 26 Sep 2019 20:40:16 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/09/lc_370_range_addition/</guid>
      <description>Question Leetcode 370: Range Addition
Assume you have an array of length n initialized with all 0&amp;rsquo;s and are given k update operations.
Each operation is represented as a triplet: [startIndex, endIndex, inc] which increments each element of subarray A[startIndex ... endIndex] (startIndex and endIndex inclusive) with inc.
Return the modified array after all k operations were executed.
Note:  You must return the copy of the given head as a reference to the cloned list.</description>
    </item>
    
    <item>
      <title>[Leetcode 768/769] Max Chunks To Make Sorted</title>
      <link>https://ericliu03.github.io/posts/2019/09/lc_769_max_chunks_to_make_sorted/</link>
      <pubDate>Fri, 20 Sep 2019 14:08:46 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/09/lc_769_max_chunks_to_make_sorted/</guid>
      <description>Question 1 Leetcode 769: Max Chunks To Make Sorted II
Given an array arr of integers (not necessarily distinct), we split the array into some number of &amp;ldquo;chunks&amp;rdquo; (partitions), and individually sort each chunk. After concatenating them, the result equals the sorted array.
What is the most number of chunks we could have made?
Note:  arr will have length in range [1, 2000]. arr[i] will be an integer in range [0, 10**8].</description>
    </item>
    
    <item>
      <title>[Leetcode 523] Continuous Subarray Sum</title>
      <link>https://ericliu03.github.io/posts/2019/09/lc_523_continuous_subarray_sum/</link>
      <pubDate>Wed, 18 Sep 2019 20:47:07 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/09/lc_523_continuous_subarray_sum/</guid>
      <description>Question Leetcode 523: Continuous Subarray Sum
Given a list of non-negative numbers and a target integer k, write a function to check if the array has a continuous subarray of size at least 2 that sums up to a multiple of k, that is, sums up to n*k where n is also an integer.
Note:  The length of the array won&amp;rsquo;t exceed 10,000. You may assume the sum of all the numbers is in the range of a signed 32-bit integer.</description>
    </item>
    
  </channel>
</rss>
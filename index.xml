<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yang&#39;s Blog</title>
    <link>https://ericliu03.github.io/</link>
    <description>Recent content on Yang&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 16 Apr 2019 21:16:39 -0700</lastBuildDate>
    
        <atom:link href="https://ericliu03.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Maximum Difference Between Node and Ancestor</title>
      <link>https://ericliu03.github.io/posts/2019/04/maximum_diff_between_node_and_ancestor/</link>
      <pubDate>Tue, 16 Apr 2019 21:16:39 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/maximum_diff_between_node_and_ancestor/</guid>
      <description>

&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/&#34; target=&#34;_blank&#34;&gt;Leetcode 1026&lt;/a&gt;:
Given the root of a binary tree, find the maximum value &lt;code&gt;V&lt;/code&gt; for which there exists &lt;strong&gt;different&lt;/strong&gt; nodes A and B where &lt;code&gt;V = |A.val - B.val|&lt;/code&gt; and A is an ancestor of B.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(A node A is an ancestor of B if either: any child of A is equal to B, or any child of A is an ancestor of B.)&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class TreeNode:
    def __init__(self, x):
        self.val = x
        self.left = None
        self.right = None
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;&lt;img class=&#34;special-img-class&#34; style=&#34;width:50%&#34; src=&#34;https://ericliu03.github.io/img/maximum_diff_between_node_and_ancestor_img1.jpg&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: [8,3,10,1,6,null,14,null,null,4,7,13]
Output: 7
Explanation: 
We have various ancestor-node differences, some of which are given below :
|8 - 3| = 5
|3 - 7| = 4
|8 - 1| = 7
|10 - 13| = 3
Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;method-1&#34;&gt;Method 1&lt;/h3&gt;

&lt;h4 id=&#34;analysis&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;Bottom up solution: we collect results from a node&amp;rsquo;s left and right child and calculate result of this node&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;each node will need three things from both left and right child

&lt;ol&gt;
&lt;li&gt;min and max num in subtree (for calculating this node&amp;rsquo;s difference with it&amp;rsquo;s max and min decendents)&lt;/li&gt;
&lt;li&gt;max diff in subtree&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;combine the results given from children&lt;/li&gt;
&lt;li&gt;calculate result with current node&amp;rsquo;s value and return&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;code&#34;&gt;Code&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def maxAncestorDiff(root):
    if root is None:
        return 0
    else:
        return helper(root)[2]


def helper(node):
    min_num = max_num = node.val
    diff = 0
    
    if node.left:
        temp = helper(node.left)
        min_num = min(min_num, temp[0])
        max_num = max(max_num, temp[1])
        diff = max(diff, temp[2])
    if node.right:
        temp = helper(node.right)
        min_num = min(min_num, temp[0])
        max_num = max(max_num, temp[1])
        diff = max(diff, temp[2])
    
    diff = max(diff, max(abs(node.val - min_num), abs(node.val - max_num)))
    
    return min_num, max_num, diff
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;method-2&#34;&gt;Method 2&lt;/h3&gt;

&lt;h4 id=&#34;analysis-1&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;Top down solution: the question is about nodes and their ancestors so we don&amp;rsquo;t need to gather and combine results from both children to calculate result&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;function is given min and max of numbers in the path from root to current node&lt;/li&gt;
&lt;li&gt;update min or max with current node&amp;rsquo;s value and pass it to it&amp;rsquo;s children&lt;/li&gt;
&lt;li&gt;when we reached the leaf, we calculate the result by using this min and max nums&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def maxAncestorDiff(root):
    return helper(root, root.val, root.val)


def helper(node, lo, hi):
    if node is None:
        return hi - lo

    lo = min(lo, node.val)
    hi = max(hi, node.val)

    return max(helper(node.left, lo, hi), helper(node.right, lo, hi))
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Longest Increasing Subsequence (Chinese)</title>
      <link>https://ericliu03.github.io/posts/2019/04/longest_increasing_subsequence/</link>
      <pubDate>Mon, 15 Apr 2019 20:03:06 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/longest_increasing_subsequence/</guid>
      <description>

&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;

&lt;p&gt;This question is from &lt;a href=&#34;https://leetcode.com/problems/longest-increasing-subsequence/&#34; target=&#34;_blank&#34;&gt;Leetcode 300&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given an unsorted array of integers, find the length of longest increasing subsequence.&lt;/p&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Input: [10,9,2,5,3,7,101,18]
Output: 4 
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;There may be more than one LIS combination, it is only necessary for you to return the length.&lt;/li&gt;
&lt;li&gt;Your algorithm should run in \( O(N^2) \) complexity.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;method-1&#34;&gt;Method 1&lt;/h3&gt;

&lt;h4 id=&#34;analysis&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;可以使用Brute force的方法来解决这个问题。
具体来说我们需要试一下所有可能的组合：对于每一个数&lt;strong&gt;x&lt;/strong&gt;，他本身加上他后面的任意一个比他大的数&lt;strong&gt;y&lt;/strong&gt;都可以组成一个increasing subsequence。如果我们已经知道了以&lt;strong&gt;y&lt;/strong&gt;开头（对，就是recursion的思想），最长能组成的subsequence的长度，我们就知道了以&lt;strong&gt;x&lt;/strong&gt;和&lt;strong&gt;y&lt;/strong&gt;开头的最长的长度。但是选y只是以x开头的increasing subsequence的可能性之一。或许有一个数字&lt;strong&gt;z&lt;/strong&gt;也符合条件（比x大，在x的后面），如果以z开头的increasing subsequence 的最长长度比以y开头的长，那么对于x来说，更好地选项就是接上z，以xz开头。 所以，为了知道最长的到底是那个，需要把后面所有符合条件的数都拿来试一下，然后选那个最长的。
时间复杂度是\( O(N!) \)：对于第一个数字，需要进行 (n-1) * (n-2) * &amp;hellip; * 1，第二个是 (n-2) * (n-3) * &amp;hellip; * 1, 第n个是1。&lt;/p&gt;

&lt;p&gt;Leetcode也提供了&lt;a href=&#34;https://leetcode.com/problems/longest-increasing-subsequence/solution/&#34; target=&#34;_blank&#34;&gt;另一种BF&lt;/a&gt;的方法。那个方法对于recursion function的定义不同，时间复杂度也只有O(2^n)。原因是相比于上面的方法，在每个点只进行了两次recursion call，而不是n次。&lt;/p&gt;

&lt;p&gt;你应该能发现我们recursion function的定义，是求以当前数字作为开头，最长的increasing subsequence的长度。既然是最长，那么也就是说只要给定start位置和list，这个结果就只有一个。然而在上面的算法中，对于同一个点我们计算了很多次（对于每个数，我们计算的次数等于他前面比他小的数字的数量）。所以我们可以把计算的结果存起来，只计算一次。&lt;/p&gt;

&lt;p&gt;那么时间复杂度就变成了\( O(N^2) \)，因为对于每个点，我们依然要看一下剩下符合要求的点的最长长度然后计算出自己的长度。&lt;/p&gt;

&lt;h4 id=&#34;code&#34;&gt;Code&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;class Solution:
    def lengthOfLIS(self, nums: List[int]) -&amp;gt; int:
        if not nums:
            return 0
        self.memo = {}
        return max([self.helper(i, nums) for i in range(len(nums))])
    
    def helper(self, start, nums):
        if start not in self.memo:
            result = 0
            for i in range(start+1, len(nums)):
                if nums[i] &amp;gt; nums[start]:
                    result = max(result, self.helper(i, nums))
            self.memo[start] = result+1
            
        return self.memo[start]

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;method-2&#34;&gt;Method 2&lt;/h3&gt;

&lt;h4 id=&#34;analysis-1&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;一般来说recursion的问题都可以优化成DP的解法，此题就是如此。我们上面说&lt;strong&gt;这里recursion function的定义，是求以当前数字作为开头，最长的increasing subsequence的长度&lt;/strong&gt;。在recursion中， 我们是从前往后call recursion function，但是实际计算是从后往前。换句话说，我们每一层recursion都需要后面一层的结果，所以第一个真正计算出的结果是最后一层，也就是&lt;strong&gt;以最后一个数字作为开头的最长的长度&lt;/strong&gt;（那便是1啦）。如果按照真正计算的顺序（即从右向左）计算，然后记录下来计算结果后给后面的计算使用，就是DP的解法。&lt;/p&gt;

&lt;p&gt;在LC中提供的DP解法是反过来，从左向右计算，随之而变化的是存的每个点的数据的定义，也变为&lt;strong&gt;以当前数字为结尾，最长increasing subsequence的长度&lt;/strong&gt;。所以对于每一个数字，我们都需要看一下符合条件的数，也即在他前面且比他小的数（可以看到是正好反过来的），找出最长的作为当前数字的结果。从前往后是自然而然的顺序，但是如果是用BF的方法推导过来，却是需要转换一下才可。&lt;/p&gt;

&lt;h4 id=&#34;code-1&#34;&gt;Code&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def lengthOfLIS(nums):
    if not nums:
        return 0

    dp = [1] * len(nums)

    for hi in range(len(nums)):
        for lo in range(hi):
            if nums[lo] &amp;lt; nums[hi]:
                dp[hi] = max(dp[hi], dp[lo] + 1)
    return max(dp)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;follow-up-1&#34;&gt;Follow up 1&lt;/h3&gt;

&lt;h4 id=&#34;question-1&#34;&gt;Question&lt;/h4&gt;

&lt;p&gt;From &lt;a href=&#34;https://leetcode.com/problems/number-of-longest-increasing-subsequence/&#34; target=&#34;_blank&#34;&gt;Leetcode 673&lt;/a&gt;:
Given an unsorted array of integers, find the number of longest increasing subsequence.&lt;/p&gt;

&lt;h4 id=&#34;examples-1&#34;&gt;Examples&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Example 1:
Input: [1,3,5,4,7]
Output: 2
Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].
Example 2:
Input: [2,2,2,2,2]
Output: 5
Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences&#39; length is 1, so output 5.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;analysis-2&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;这个题目和上面题目唯一不同的地方就是之前的是求最长的长度，这个是求拥有最长长度的subsequence有多少个。如果你walk through了之前的DP解法就会发现，同样长度的结果的确可能遇到过多个。比如我们在例子1中最后一个数字7的时候，在index为2和3（就是数字5和4）时，DP[2]和DP[3]都应该等于3，因为135和134长度都为3。那么在上面DP解法第十行的&lt;code&gt;dp[j] = max(dp[j], dp[i] + 1)&lt;/code&gt;就是说明dp[j]等于dp[i]+1。&lt;/p&gt;

&lt;p&gt;在本题目中我们需要记录下来遇到这种情况的数量，也就是在每一位不仅记录以当前为结尾数字的subsequence的最大长度，也记录有此长度的不同subsequence有多少个。这样一来，最后的时候我们就可以使用整个dp数组中最长的那个长度，作为整个数组的最长度，再用这个长度去找总共这个长度的subsequence有多少个。&lt;/p&gt;

&lt;h4 id=&#34;code-2&#34;&gt;Code&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def numberOfLIS(nums):
        if not nums:
            return 0
        
        dp = [1] * len(nums)
        counts = [1] * len(nums)
        
        for hi in range(len(nums)):
            for lo in range(hi):
                if nums[lo] &amp;lt; nums[hi]:
                    if dp[hi] &amp;lt; dp[lo] + 1:
                        dp[hi] = dp[lo] + 1
                        counts[hi] = counts[lo]
                    elif dp[hi] == dp[lo] + 1:
                        counts[hi] += counts[lo]

        max_len  = max(dp)
        return sum([counts[i] for i in range(len(nums)) if dp[i] == max_len])
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;follow-up-2&#34;&gt;Follow up 2&lt;/h3&gt;

&lt;h4 id=&#34;question-2&#34;&gt;Question&lt;/h4&gt;

&lt;p&gt;From &lt;a href=&#34;https://leetcode.com/problems/longest-arithmetic-sequence/&#34; target=&#34;_blank&#34;&gt;Leetcode 1027&lt;/a&gt;:
Given an array A of integers, return the length of the longest arithmetic subsequence in A.&lt;/p&gt;

&lt;p&gt;Recall that a subsequence of A is a list &lt;code&gt;A[i_1], A[i_2], ..., A[i_k]&lt;/code&gt; with &lt;code&gt;0 &amp;lt;= i_1 &amp;lt; i_2 &amp;lt; ... &amp;lt; i_k &amp;lt;= A.length - 1&lt;/code&gt;, and that a sequence B is arithmetic if &lt;code&gt;B[i+1] - B[i]&lt;/code&gt; are all the same value (for &lt;code&gt;0 &amp;lt;= i &amp;lt; B.length - 1&lt;/code&gt;).&lt;/p&gt;

&lt;h4 id=&#34;examples-2&#34;&gt;Examples&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Example 1
Input: [9,4,7,2,10]
Output: 3
Explanation: 
The longest arithmetic subsequence is [4,7,10].

Example 2:
Input: [20,1,15,3,10,5,8]
Output: 4
Explanation: 
The longest arithmetic subsequence is [20,15,10,5].
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;analysis-3&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;看过了上面这么多题目和解法，看到这应该有感觉到需要用类似的方法做。和原题唯一的区别就是条件：原题的条件是右边的数大于左边的数，此题的条件是右边的数减左边的数等于一个差值。这个差值是由subsequence的头两个数决定的。同样的，我们可以用一个数组&lt;code&gt;dp[]&lt;/code&gt;来存以当前数字为结尾的subsequence的最长长度，但不同的是对于不一样的差值可以会有相同或者不同的最长长度，比如例子1中，以7结尾，差值为-2时，长度为2，差值为3时长度也为2（未出现的差值我们可以不记录）。在比如当到了10的时候，差值为3是就是3（接上了7），其他的（比如1，6等等）最长的只有2了。所以我们可以想到，对于每一个数字的每一种可能的差值，我们都需要记录下来其最长subsequence的长度，以备后面的数字使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def longestArithSeqLength(nums):
    dp = [collections.defaultdict(int) for _ in range(len(nums))]
    result = 0
    
    for hi in range(len(nums)):
        for lo in range(hi):
            diff = nums[hi] - nums[lo]
            dp[hi][diff] = max(dp[hi][diff], dp[lo][diff] + 1)
            result = max(result, dp[hi][diff])        
    return result + 1	

&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;后记&#34;&gt;后记&lt;/h3&gt;

&lt;p&gt;这篇文章其实是收到了最后一个题目（follow up2）的启发，是在做LC contest的时候遇到的。回忆起来，当时感觉题目有点熟悉，但没想到和原题的关联。当时只想到了BF算法，自然也超时了。理论上用BF加memo的方法也可以做，但是因为加入了diff的缘故导致稍微有点复杂，就被绕晕了。想要思路清晰的快速解题，还是要熟练啊&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Inorder Predecessor</title>
      <link>https://ericliu03.github.io/posts/2019/04/inorder_predecessor/</link>
      <pubDate>Sat, 13 Apr 2019 21:55:51 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/inorder_predecessor/</guid>
      <description>

&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;

&lt;p&gt;Given a node in a binary tree, return the inorder predecessor of that node. If it doesn&amp;rsquo;t exist, return null. Both input and output should be node objects.&lt;/p&gt;

&lt;p&gt;Node is given as an object with pointers to it&amp;rsquo;s left child, right child and parent.&lt;/p&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;     A
    / \
   B   C
  / \
 D   E
    /
   F

In order traversal: DBFEAC
If give A, then return should be E. 
If give C, should return A. 
If give F, should return B. 
If give D, return null.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;algorithm&#34;&gt;Algorithm&lt;/h2&gt;

&lt;h4 id=&#34;method-1&#34;&gt;Method 1&lt;/h4&gt;

&lt;h4 id=&#34;analysis&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;First, there are &lt;a href=&#34;https://en.wikipedia.org/wiki/Tree_traversal&#34; target=&#34;_blank&#34;&gt;several ways&lt;/a&gt; to traverse a tree, and in the problem it&amp;rsquo;s using in-order traversal. Basically, in-order traversal is to &amp;ldquo;display root node at &lt;em&gt;in&lt;/em&gt; position&amp;rdquo;, i.e. 1. display left subtree, display root and display right sub tree. Something like this: &lt;strong&gt;[left-subtree-inorder-list] + root + [right-subtree-inorder-list]&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For this question, the easiest way is to find the root of the tree using the pointer to parent in each node, and do a in-order traversal to generate a list. The time and space complexity would be O(n). Can we do better?&lt;/p&gt;

&lt;h4 id=&#34;method-2&#34;&gt;Method 2&lt;/h4&gt;

&lt;h4 id=&#34;analysis-1&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;We have the pointer to parents, so we should be able to go anywhere in the graph. The question is where to go?&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say &lt;strong&gt;X&lt;/strong&gt; is the node given:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Case 1: if X has left child as &lt;strong&gt;A&lt;/strong&gt; in example. Then we are sure it&amp;rsquo;s predecessor is in it&amp;rsquo;s left subtree, and it should be the last node of the subtree&amp;rsquo;s inorder list. The last node in the in-order traversal of a tree will be the right most node in the tree. As a result, &lt;strong&gt;we go left, and go right until no right child.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Case 2: if X doesn&amp;rsquo;t have left child, it means in the subtree where X is the root, X is the first node in it&amp;rsquo;s inorder list. We have to find it&amp;rsquo;s predecessor outside of this subtree. So thinking about X&amp;rsquo;s parent &lt;strong&gt;Y&lt;/strong&gt;,

&lt;ul&gt;
&lt;li&gt;Case 2.1: if X is Y&amp;rsquo;s right child as &lt;strong&gt;C&lt;/strong&gt; in example, Y will the X&amp;rsquo;s predecessor: X is the first node (in-order) in Y&amp;rsquo;s right subtree.&lt;/li&gt;
&lt;li&gt;Case 2.2: if X is Y&amp;rsquo;s left child as &lt;strong&gt;F&lt;/strong&gt; in example, then Y will not be the predecessor: Y&amp;rsquo;s right subtree plus Y will be after X in the in-order list. &lt;strong&gt;X will still be the first node in the inorder list that generated from the subtree with Y as the root&lt;/strong&gt;. Then if we go one level up to Y&amp;rsquo;s parent &lt;strong&gt;Z&lt;/strong&gt;, it will be a similar situation: if Y is Z&amp;rsquo;s left child, Z plus all the nodes in Z&amp;rsquo;s right subtree will be after Y, and thus X, in the inorder list. We have to go up, until we meet a case like case 2.1, where &lt;strong&gt;Y*&lt;/strong&gt; is &lt;strong&gt;Z*&amp;rsquo;s&lt;/strong&gt; right child. In this case, in subtree with Z* as root, Z* will be in the middle, and X is the first node in the inorder list of Z*&amp;rsquo;s right subtree, which means X&amp;rsquo;s predecessor is Z*.&lt;/li&gt;
&lt;li&gt;Case 2.3: As &lt;strong&gt;D&lt;/strong&gt; in example, If we can&amp;rsquo;t find a node like Z* and we don&amp;rsquo;t have a &amp;ldquo;parent&amp;rdquo; to go up any more, then it means X is the first node in the inorder list and we should return null.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;code&#34;&gt;Code&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def inorder_predecessor(node):
    if node is None:
        return None

    if node.left is not None:
        curr = node.left
        while curr.right:
            curr = curr.right
        return curr
    else:
        while node.parent:
            if node.parent.right == node:
                return node.parent
            else:
                node = node.parent
        return None

class Node:
    def __init__(self, val, parent):
        self.val = val
        self.parent = parent
        self.left = None
        self.right = None

    def __str__(self):
        return self.val
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Minimum Point to Traverse Graph</title>
      <link>https://ericliu03.github.io/posts/2019/04/minimum_point_to_traverse_graph/</link>
      <pubDate>Wed, 10 Apr 2019 15:38:14 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/minimum_point_to_traverse_graph/</guid>
      <description>

&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;

&lt;p&gt;There is a directed graph and you can traverse the nodes in this graph by following the directed edges. You can start from any node in this graph and you can pick nodes as start points as many as you needed. What is the minimum number of nodes as start points you need to traverse all the nodes?&lt;/p&gt;

&lt;p&gt;You will be given a number n as number of vertices in the graph, and a list contains all the edges in the graph.&lt;/p&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;input: 4, [[0,1], [1,2],[2,3]]
output: 1. we just need to pick 1 as start point and will be able to traverse the whole graph
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;input: 4, [[2,1], [3,1],[0,1]]
output: 3. we have to start from 2,3 and 4 to reach all the nodes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 3:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;input: 6, [[0,1], [1,2], [2,0], [2,3], [3,4], [4,5], [5,3]]
output: 1, we could start from 3, then we could go through 0-&amp;gt;1-&amp;gt;2-&amp;gt;0, and 2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 4:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;input: 5, [[0, 1], [1, 2], [2, 3], [3, 0], [4, 0]]
output: 1, we start from 4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;algorithm&#34;&gt;Algorithm&lt;/h2&gt;

&lt;h3 id=&#34;method-1&#34;&gt;Method 1&lt;/h3&gt;

&lt;h4 id=&#34;analysis&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;Starting from the problem description, the most straightforward is to use a recursive method. We could have a loop of all the nodes in the graph. We treat each node as a start point of a DFS and see if we can traverse the whole graph. If yes, then we return 1 since we used 1 node as start point. If not, then we go 1 level deeper in the recursive function, which is another loop of the nodes, but here instead of all the nodes, we only use the nodes we can&amp;rsquo;t reach in the previous DFS. We should be able to get one result for each node that picked as starting point. We choose the smallest number among those and plus one to return as the nodes needed to cover all the nodes.&lt;/p&gt;

&lt;h4 id=&#34;code&#34;&gt;Code&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import collections

def minimum_nodes(n, edges):
    outdegrees = collections.defaultdict(set)
    for u, v in edges:
        outdegrees[u].add(v)

    result = float(&#39;inf&#39;)
    unvisited = set([i for i in range(n)])
    for i in range(n):
        result = min(result, dfs(i, outdegrees, unvisited))
        print(result, i)
    return result


def dfs(start, outdegrees, unvisited):
    unvisited_set = unvisited.copy()
    queue = [start]
    while queue:
        curr_node = queue.pop(0)
        if curr_node in unvisited_set:
            unvisited_set.remove(curr_node)
            for neighbor in outdegrees[curr_node]:
                queue.append(neighbor)

    if len(unvisited_set) == 0:
        return 1
    else:
        result = float(&#39;inf&#39;)
        for unvisited in unvisited_set:
            result = min(result, dfs(unvisited, outdegrees, unvisited_set))
        return result + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;method-2&#34;&gt;Method 2&lt;/h3&gt;

&lt;h4 id=&#34;analysis-1&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;Thinking about the recursive function, we should notice that we did a lot duplicated works there. (Actually, if the problem is not asking for all possible ways/permutations, then there should always be duplicated works.) In this way, this could be optimized using idea of &lt;a href=&#34;https://en.wikipedia.org/wiki/Dynamic_programming&#34; target=&#34;_blank&#34;&gt;Dynamic Programing&lt;/a&gt;. There are two general ways of doing DP, 1. use a map to remember what&amp;rsquo;s the result from a start point (in this problem the start point is the node we choose as start), and go through the path using recursive function 2. use a n-Dimension array to store the result and derive results from previous results.
Here we could use the first way to remember the result of &lt;strong&gt;the nodes we could reach when starting from node u&lt;/strong&gt;. Then each time we start the DFS, we first check if we have already examen that node as start point and if we do return the result.&lt;/p&gt;

&lt;h4 id=&#34;code-1&#34;&gt;Code&lt;/h4&gt;

&lt;p&gt;This is similar to method 1, just we remember the results we already have. But the code looks messier =|&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def minimum_nodes(n, edges):
    memo = {}
    outdegrees = collections.defaultdict(set)
    for u, v in edges:
        outdegrees[u].add(v)

    result = float(&#39;inf&#39;)
    unvisited = set([i for i in range(n)])
    for i in range(n):
        result = min(result, dfs(i, memo, outdegrees, unvisited))
        print(result, i)
    return result


def dfs(start, memo, outdegrees, unvisited):
    if start in memo:
        return memo[start]
    unvisited_set = unvisited.copy()
    queue = [start]
    while queue:
        curr_node = queue.pop(0)
        if curr_node in unvisited_set:
            unvisited_set.remove(curr_node)
            for neighbor in outdegrees[curr_node]:
                queue.append(neighbor)

    result = float(&#39;inf&#39;)
    if len(unvisited_set) == 0:
        result = 1
    else:
        for unvisited in unvisited_set:
            result = min(result, dfs(unvisited, memo, outdegrees, unvisited_set))
        result += 1

    memo[start] = result
    return result
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;method-3&#34;&gt;Method 3&lt;/h3&gt;

&lt;h4 id=&#34;analysis-2&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;Instead of remembering everything in a map during the recursion, we could remember something else. There are two things we need, 1. the vertices we already visited in &lt;code&gt;visited&lt;/code&gt;, 2. the start points we choose in &lt;code&gt;start_points&lt;/code&gt;. Still, we loop through every vertex, say &lt;strong&gt;u&lt;/strong&gt; in the graph that not in &lt;code&gt;visited&lt;/code&gt;, do a search (either DFS or BFS) to get all the vertices that could be reached started with &lt;strong&gt;u&lt;/strong&gt;. The following is the &lt;strong&gt;key&lt;/strong&gt; to this algorithm: 1. we add those reached vertices to &lt;code&gt;visited&lt;/code&gt;, so we won&amp;rsquo;t do duplicated work, 2. if in the reached vertices, there&amp;rsquo;s any &lt;strong&gt;start points we chose, we remove those start points,&lt;/strong&gt; from &lt;code&gt;start_points&lt;/code&gt;. 3. add &lt;strong&gt;u&lt;/strong&gt; to &lt;code&gt;start_points&lt;/code&gt;. This is because we could reach the &lt;strong&gt;removed start points&lt;/strong&gt; from &lt;strong&gt;u&lt;/strong&gt;, and thus the vertices that the old start vertex can reach. So there&amp;rsquo;s no need to keep the old start point anymore.&lt;/p&gt;

&lt;h4 id=&#34;code-2&#34;&gt;Code&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def minimum_nodes3(n, edges):
    outdegrees = collections.defaultdict(set)
    for u, v in edges:
        outdegrees[u].add(v)

    visited = set()
    starts = set()
    for vertex in range(n):
        if vertex in visited:
            continue

        reached = get_reached(vertex, outdegrees)
        for s in list(starts):
            if s in reached:
                starts.remove(s)
        visited.update(reached)
        starts.add(vertex)

    return len(starts)


def get_reached(start, outdegrees):
    visited = set()
    queue = [start]
    while queue:
        curr_node = queue.pop(0)
        if curr_node in visited:
            continue

        visited.add(curr_node)
        for neighbor in outdegrees[curr_node]:
            queue.append(neighbor)

    return visited
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;method-4&#34;&gt;Method 4&lt;/h3&gt;

&lt;h4 id=&#34;analysis-3&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;In the graph theory, there&amp;rsquo;s a concept called &lt;a href=&#34;https://en.wikipedia.org/wiki/Strongly_connected_component&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;Strongly Connected Component(SCC)&lt;/strong&gt;&lt;/a&gt;. If you don&amp;rsquo;t know you should read about it. In short, all nodes in a SCC has a path to go to any other nodes in the same SCC. So what we need from it for this problem is that we want to treat the nodes in same SCC as one single node in a graph. After that the graph will be a DAG, and we just need to count how many nodes don&amp;rsquo;t have incoming edges (i.e. 0 in-degree). Those nodes will be the start points.&lt;/p&gt;

&lt;p&gt;In reference 1, code for this solution is given, which used Tarjan Algorithm. I attached some great explanation in reference for this algorithm. I will write my understanding of Tarjan in the following. It uses a stack to represent the vertices that are currently visiting, and it uses &lt;code&gt;dfn[u]&lt;/code&gt; to store IDs of vertices and &lt;code&gt;low[u]&lt;/code&gt; to represent the vertex with lowest ID it can reach. As an example, is 6 can reach 4 (so &lt;code&gt;low[6] = 4&lt;/code&gt;), and 4 can reach 1 (&lt;code&gt;low[4] = 1&lt;/code&gt;). From this we know 6 can reach 1 but during the algorithm this will not be recorded directly in &lt;code&gt;low&lt;/code&gt;. If &lt;code&gt;low[x]&lt;/code&gt; equals to x itself, then it means it can&amp;rsquo;t go back any further, and it will be recognized as &lt;em&gt;root&lt;/em&gt; of this SCC. Thus all the vertices in the stack and pushed later then this &lt;em&gt;root&lt;/em&gt; (i.e. we are visiting) will belongs to this SCC. This is because from this &lt;em&gt;root&lt;/em&gt; we reached all those vertices, and somehow those vertices can comes back to this &lt;em&gt;root&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In my opinion this is way more complicated in an interview, so I will just skip it here.&lt;/p&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;amp;tid=319799&#34; target=&#34;_blank&#34;&gt;[树/链表/图] 求教Airbnb的graph traversal问题 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.miskcoo.com/2016/07/tarjan-algorithm-strongly-connected-components&#34; target=&#34;_blank&#34;&gt;Tarjan算法寻找有向图的强连通分量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/hurmishine/article/details/75248876&#34; target=&#34;_blank&#34;&gt;全网最!详!细!Tarjan算法讲解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/nullzx/p/6437926.html&#34; target=&#34;_blank&#34;&gt;Kosaraju算法解析: 求解图的强连通分量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/dm_vincent/article/details/8554244&#34; target=&#34;_blank&#34;&gt;求解强连通分量算法之&amp;mdash;Kosaraju算法&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Video Stitching</title>
      <link>https://ericliu03.github.io/posts/2019/04/video_stitching/</link>
      <pubDate>Mon, 08 Apr 2019 20:01:29 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/video_stitching/</guid>
      <description>

&lt;p&gt;This is a question from &lt;a href=&#34;https://leetcode.com/problems/video-stitching/&#34; target=&#34;_blank&#34;&gt;leetcode.com&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;problem&#34;&gt;Problem&lt;/h2&gt;

&lt;h3 id=&#34;question&#34;&gt;Question&lt;/h3&gt;

&lt;p&gt;You are given a series of video clips from a sporting event that lasted T seconds.  These video clips can be overlapping with each other and have varied lengths.&lt;/p&gt;

&lt;p&gt;Each video clip &lt;code&gt;clips[i]&lt;/code&gt; is an interval: it starts at time &lt;code&gt;clips[i][0]&lt;/code&gt; and ends at time &lt;code&gt;clips[i][1]&lt;/code&gt;.  We can cut these clips into segments freely: for example, a clip &lt;code&gt;[0, 7]&lt;/code&gt; can be cut into segments &lt;code&gt;[0, 1] + [1, 3] + [3, 7]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event (&lt;code&gt;[0, T]&lt;/code&gt;).  If the task is impossible, return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10
Output: 3
Explanation: 
We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.
Then, we can reconstruct the sporting event as follows:
We cut [1,9] into segments [1,2] + [2,8] + [8,9].
Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: clips = [[0,1],[1,2]], T = 5
Output: -1
Explanation: 
We can&#39;t cover [0,5] with only [0,1] and [0,2].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 3:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9
Output: 3
Explanation: 
We can take clips [0,4], [4,7], and [6,9].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 4:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: clips = [[0,4],[2,8]], T = 5
Output: 2
Explanation: 
Notice you can have extra video after the event ends.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 &amp;lt;= clips.length &amp;lt;= 100
0 &amp;lt;= clips[i][0], clips[i][1] &amp;lt;= 100
0 &amp;lt;= T &amp;lt;= 100
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;analysis&#34;&gt;Analysis&lt;/h2&gt;

&lt;p&gt;If we take the core of the problem out, what we need to find is minimum number of ranges that covers [0, T].&lt;/p&gt;

&lt;p&gt;We can start with 0, since 0 is the starting point (left-most position) and we have to cover it. By checking all the sections that starts &amp;lt;= 0, we will know the how long we can reach to the right. For example, in example 3, we have &lt;code&gt;[0,1], [0,2], [0,3], [0,4]&lt;/code&gt;. Then in next step, we could reach any sections that start &amp;lt;= 4. So we will loop through all the sections again and find how long we can reach to the right. If we have &lt;code&gt;[2,9]&lt;/code&gt; and &lt;code&gt;[4,8]&lt;/code&gt;, we will know we can reach 9.&lt;/p&gt;

&lt;p&gt;So in each scan, we will know how far we can reach and once we reach further than T or we can&amp;rsquo;t move, we finished scan and return the result.&lt;/p&gt;

&lt;h2 id=&#34;algorithm&#34;&gt;Algorithm&lt;/h2&gt;

&lt;h3 id=&#34;method-1&#34;&gt;Method 1:&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def video_stitching(clips, T):
    curr_reached = 0
    count = 0

    while curr_reached &amp;lt; T:
        next_reached = curr_reached
        for start, end in clips:
            if start &amp;lt;= curr_reached and end &amp;gt; next_reached:
                next_reached = end
        count += 1
        if next_reached == curr_reached:
            count = -1
            break
        else:
            curr_reached = next_reached

    return count
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time complexity: in the worst case, we move one section by one section and need to loop through every section for each section, so \( O(N^2) \)&lt;/p&gt;

&lt;h3 id=&#34;method-2&#34;&gt;Method 2:&lt;/h3&gt;

&lt;p&gt;First we sort this clips based on start time (end time doesn&amp;rsquo;t matter because we will scan all of them). Then during the loop, we will keep record of how far we can go in next round and stop at the section whose start is greater than our current reached point (so that we can concatenate). So in next round, we start at where we stopped and do the same thing.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def video_stitching2(clips, T):
    clips.sort()
    curr_reached = 0
    count = 0
    pos = 0

    while pos &amp;lt; len(clips) and curr_reached &amp;lt; T:
        next_reached = curr_reached
        while pos &amp;lt; len(clips) and clips[pos][0] &amp;lt;= curr_reached:
            next_reached = max(next_reached, clips[pos][1])
            pos += 1
        count += 1
        if next_reached == curr_reached:
            break
        else:
            curr_reached = next_reached

    return count if curr_reached &amp;gt;= T else -1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Time complexity: the scan is \( O(N) \) but sorting is \( O(NlogN) \). So overall the time complexity is \( O(NlogN) \)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pour Water</title>
      <link>https://ericliu03.github.io/posts/2019/04/pour_water/</link>
      <pubDate>Sun, 07 Apr 2019 14:51:09 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/pour_water/</guid>
      <description>

&lt;p&gt;This is a question from Airbnb onsite interview, also could be found on &lt;a href=&#34;https://leetcode.com/problems/pour-water/&#34; target=&#34;_blank&#34;&gt;leetcode&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;question&#34;&gt;Question:&lt;/h2&gt;

&lt;p&gt;We are given an elevation map, &lt;code&gt;heights[i]&lt;/code&gt; representing the height of the terrain at that index. The width at each index is 1. After V units of water fall at index K, how much water is at each index?&lt;/p&gt;

&lt;h3 id=&#34;assumptions&#34;&gt;Assumptions:&lt;/h3&gt;

&lt;p&gt;Now, you should ask some clarify questions and make some assumptions of this questions. There are a lot of good solutions and explanations on &lt;a href=&#34;https://leetcode.com/problems/pour-water/solution/&#34; target=&#34;_blank&#34;&gt;leetcode&lt;/a&gt; so I will have a different version of the assumption here.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If the droplet would eventually fall by moving &lt;strong&gt;right&lt;/strong&gt;, then move &lt;strong&gt;right&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Otherwise, if the droplet would eventually fall by moving &lt;strong&gt;left&lt;/strong&gt;, then move &lt;strong&gt;left&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Water will move as many as possible.&lt;/li&gt;
&lt;li&gt;However, if the eventually fall position is the first or last position of the map, the water drop will overflow and disappear.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here, &lt;strong&gt;&amp;ldquo;eventually fall&amp;rdquo;&lt;/strong&gt; means that the droplet will eventually be at a lower level if it moves in that direction. Also, &amp;ldquo;level&amp;rdquo; means the height of the terrain plus any water in that column.&lt;/p&gt;

&lt;p&gt;If there&amp;rsquo;s no place for water to eventually fall without overflow, then&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The water drop will overflow either overflow from left or right.&lt;/li&gt;
&lt;li&gt;Otherwise, it will stay at the right most possible position.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Input: heights = [2,1,1,2,1,2,2], V = 4, K = 3
Output: [2,2,2,3,2,2,2]
Steps:
1. [2,1,1,2,2,2,2]
2. [2,2,1,2,2,2,2]
3. [2,2,2,2,2,2,2]
4. [2,2,2,2,2,2,2] (overflow)

Input: heights = [1,2,3,4], V = 1, K = 2
Output: [1,2,3,4]
Steps:
1. [1,2,3,4] (overflow)

Input: heights = [2,1,1,4], V = 3, K = 1
Output: [2,2,2,4]
Steps:
1. [2,1,2,4]
1. [2,2,2,4]
1. [2,2,2,4] (overflow)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;analysis&#34;&gt;Analysis&lt;/h2&gt;

&lt;p&gt;With these assumptions, this question is a bit complicated than the one in leetcode. We need to explicitly deal with some conditions. For example, instead of overflow, we have high walls on both sides, we don&amp;rsquo;t need to care about whether we will overflow or not.&lt;/p&gt;

&lt;h3 id=&#34;conditions&#34;&gt;Conditions&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;On right side find the 1. right most position, 2. lowest level, 3.water can flow there (water can&amp;rsquo;t flow up)&lt;/li&gt;
&lt;li&gt;Do the same on the left side.&lt;/li&gt;
&lt;li&gt;Check if we overflow: checking the level of the position we find on both left and right sides. One in overflow position and the other is either in overflow position or the level of that position is not lower than dropping position(V), then we will overflow.&lt;/li&gt;
&lt;li&gt;Otherwise, find the correct position, it should be the one on right side, unless the right position is not a &lt;strong&gt;&amp;lsquo;eventually fall&amp;rsquo;&lt;/strong&gt; position while the one on the left is.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;coding&#34;&gt;Coding&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def pour_water(elevation, drop_count, drop_pos):
    n = len(elevation)
    for _ in range(drop_count):
        right_pos = drop_pos
        left_pos = drop_pos

        while right_pos + 1 &amp;lt; n and elevation[right_pos + 1] &amp;lt;= elevation[right_pos]:
            right_pos += 1
        while left_pos - 1 &amp;gt;= 0 and elevation[left_pos - 1] &amp;lt;= elevation[left_pos]:
            left_pos -= 1

        next_pos = right_pos
        if (right_pos == n - 1 and left_pos == 0) \
                or (right_pos == n - 1 and elevation[left_pos] == elevation[drop_pos]) \
                or (left_pos == 0 and elevation[right_pos] == elevation[drop_pos]):
            continue
        elif elevation[right_pos] == elevation[drop_pos] and elevation[left_pos] &amp;lt; elevation[drop_pos]:
            next_pos = left_pos

        elevation[next_pos] += 1
    return elevation
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;tips&#34;&gt;Tips&lt;/h3&gt;

&lt;p&gt;When scanning using while loop, we can check the value on next index before moving forward. In this way, our result index will be the last one that satisfy the while condition. Be attention that the first index is not checked.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Create tree from tuples</title>
      <link>https://ericliu03.github.io/posts/2019/04/remove_undirect_edge/</link>
      <pubDate>Sat, 06 Apr 2019 16:55:31 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/remove_undirect_edge/</guid>
      <description>

&lt;p&gt;This is a coding problem from Uber onsite interview found &lt;a href=&#34;https://www.1point3acres.com/bbs/thread-502555-1-1.html&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;question&#34;&gt;Question:&lt;/h3&gt;

&lt;p&gt;Given a list of pairs (tuples), each of them represents a connection from parent to it&amp;rsquo;s child in a tree. In this list, nodes will have edges not only for their direct children, but also all of it&amp;rsquo;s descendants (i.e. children&amp;rsquo;s children, and their children etc).&lt;/p&gt;

&lt;p&gt;If we have the following tree as an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    A
   / \
  B   C
 / \
 D  E
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the list given it will be&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; [(A,B), (A,D), (A,E), (A,C), (B,D), (B,E)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can assume the tuples given will result in a valid tree. Use this list to construct a tree.&lt;/p&gt;

&lt;h3 id=&#34;analysis&#34;&gt;Analysis&lt;/h3&gt;

&lt;p&gt;Intuitively, what we want to do is to remove the connections &lt;em&gt;a -&amp;gt; b&lt;/em&gt; while a is not the node&amp;rsquo;s parent in the tree. The way to distinguish those connections is to find out if there&amp;rsquo;s another way to connect a -&amp;gt; b. If there is any, saying a -&amp;gt; a&amp;rsquo; -&amp;gt; b, then we know b&amp;rsquo;s parent is a&amp;rsquo; instead a then we should remove a -&amp;gt; b.&lt;/p&gt;

&lt;p&gt;From a different perspective, if we imagine the tuples in the list are the edges in a directed graph, then we want is a &lt;a href=&#34;https://en.wikipedia.org/wiki/Transitive_reduction&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;transitive reduction&lt;/strong&gt;&lt;/a&gt; of the original graph (represented by all the edges). The transitive reduction of a graph contains &lt;em&gt;the fewest possible edges that has the same reachability relation as the original graph, by discarding the edges u → v for which G also contains a longer path connecting the same two vertices.&lt;/em&gt; In this way, the transitive reduction we generated will be the tree the question asked.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;list given is a &lt;strong&gt;partially ordered set&lt;/strong&gt; of a &lt;a href=&#34;https://en.wikipedia.org/wiki/Directed_acyclic_graph&#34; target=&#34;_blank&#34;&gt;&lt;strong&gt;DAG&lt;/strong&gt; (Directed Acyclic Graph)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;You can also find it &lt;a href=&#34;https://algs4.cs.princeton.edu/42digraph/&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt; at item 38 in &lt;em&gt;Web Exercises&lt;/em&gt; section.&lt;/li&gt;
&lt;li&gt;This question is a &lt;strong&gt;tree&lt;/strong&gt; problem, but actually it&amp;rsquo;s asking for a solution that generates the transitive reduction of a &lt;strong&gt;graph&lt;/strong&gt;. It&amp;rsquo;s important to &lt;em&gt;look beyond the surface&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;algorithm&#34;&gt;Algorithm&lt;/h3&gt;

&lt;h4 id=&#34;method-0-dfs&#34;&gt;Method 0: DFS&lt;/h4&gt;

&lt;p&gt;Following the intuitive algorithm, we could loop through every node &lt;strong&gt;u&lt;/strong&gt; in the graph and remove the edges &lt;strong&gt;u-&amp;gt;v&lt;/strong&gt; if there are other paths that connect from &lt;strong&gt;u&lt;/strong&gt; to &lt;strong&gt;v&lt;/strong&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import collections

def generate_tree0(edges):

    children = collections.defaultdict(set)
    nodes = set()
    for u, v in edges:
        children[u].add(v)
        nodes.add(u)
        nodes.add(v)

    def dfs(start, target):
        if start == target:
            return True
        result = False
        for next_node in children[start]:
            # in case we have edge that points to a node itself
            if next_node != start:
                result = result or dfs(next_node, target)
        return result

    for node in nodes:
        for child in list(children[node]):
            found = False
            for other_child in list(children[node]):
                if other_child != child and dfs(other_child, child):
                    found = True
                    break
            if found:
                children[node].remove(child)

    return children
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Complexity:
 If we have N nodes, for each node we have to go to every other nodes in worst case so time complexity should be \( O(N^2) \).&lt;/p&gt;

&lt;h4 id=&#34;method-1-topological-sort&#34;&gt;Method 1: Topological Sort&lt;/h4&gt;

&lt;p&gt;We want to remove the edges that connects u-&amp;gt;v if there are other longer paths. From another perspective, we want to keep the path from &lt;strong&gt;root -&amp;gt; v&lt;/strong&gt; with longest path. From the description we a vertex will have a edge to all of it&amp;rsquo;s decedents, which means a vertex will have all the edges from all of it&amp;rsquo;s ancestors (indegree[v] = len(path_from_root). If we order the edges by the distance in the longest path, then we only keep the closest one. Here we can use &lt;a href=&#34;https://en.wikipedia.org/wiki/Topological_sorting&#34; target=&#34;_blank&#34;&gt;Topological sort&lt;/a&gt; to get the order. In the process of sorting, in each round we will have node &lt;strong&gt;u&lt;/strong&gt; that have no edge from others to u (i.e. 0 &lt;a href=&#34;https://en.wikipedia.org/wiki/Directed_graph#Indegree_and_outdegree&#34; target=&#34;_blank&#34;&gt;indegree&lt;/a&gt;). For every one of it&amp;rsquo;s neighbors &lt;strong&gt;v&lt;/strong&gt; it connects &lt;em&gt;to&lt;/em&gt;, if there&amp;rsquo;s any other nodes &lt;strong&gt;x&lt;/strong&gt; connects &lt;strong&gt;to&lt;/strong&gt; v, then it means there will be longer path(s) that connects from &lt;strong&gt;u&lt;/strong&gt; to &lt;strong&gt;v&lt;/strong&gt;, then the edge u-&amp;gt;v should be discarded.&lt;/p&gt;

&lt;p&gt;We will use two maps to keep track of the indegrees and outdegrees of a node, and do edits in the process of sorting.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;import collections

def generate_tree0(edges):
    indegrees = collections.defaultdict(int)
    outdegrees = collections.defaultdict(set)

    for u, v in edges:
        indegrees[v] += 1
        if u not in indegrees:
            indegrees[u] = 0
        outdegrees[u].add(v)

    queue = [u for u, count in indegrees.items() if indegrees[u] == 0]
    while queue:
        curr_node = queue.pop(0)
        for neighbor in list(outdegrees[curr_node]):
            if indegrees[neighbor] == 1:
                queue.append(neighbor)
            else:
                indegrees[neighbor] -= 1
                outdegrees[curr_node]remove(neighbor)
    return outdegrees
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Complexity:
 If we have N nodes, for each node we have to go to every other nodes in worst case so time complexity should be \( O(N) \). .&lt;/p&gt;

&lt;h4 id=&#34;other-thoughts-bottom-up&#34;&gt;other thoughts: bottom up&lt;/h4&gt;

&lt;p&gt;Goal is still the same, just this time we check our parent&amp;rsquo;s children. We first pick the nodes with zero-outdegree (i.e leaf nodes) and check one by one. If the a node &lt;strong&gt;v&lt;/strong&gt; is the only child of it&amp;rsquo;s parent &lt;strong&gt;u&lt;/strong&gt;, then we should keep that edge &lt;strong&gt;u-&amp;gt;v&lt;/strong&gt; and remove all other edges that connected to &lt;em&gt;v&lt;/em&gt;. This could be seen as a variation of topological sort.&lt;/p&gt;

&lt;p&gt;However, the problem is that we don&amp;rsquo;t know which parent should we keep. For example, we have a leaf node v and it have parents u1 and u2, then which one should we keep? from the desription above, if we keep the parent that has only one child, then what about the situations that v has a sibling v2? i.e u2 -&amp;gt; v and u2 -&amp;gt; v2, then we should keep u2 as the parent.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Interviews</title>
      <link>https://ericliu03.github.io/posts/2019/04/interviews/</link>
      <pubDate>Fri, 05 Apr 2019 09:20:41 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/interviews/</guid>
      <description>&lt;p&gt;This is actually why (or saying the trigger) I create a website and begin blogging.&lt;/p&gt;

&lt;p&gt;Recently I was preparing for changing job. Inevitably I have to prepare for the coding interviews. It was funny that the recruiters from all of the companies I interviewed with suggests online coding websites to get prepared, and first ones of every list is &lt;a href=&#34;www.leetcode.com&#34; target=&#34;_blank&#34;&gt;leetcode.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;During these 3 months in preparing, I was discussing with my teammates/friends about what we want to see from interviews as interviewers. We agreed that the thought process is most important one, and then it&amp;rsquo;s the problem itself, since it&amp;rsquo;s possible to get stuck, or go some circles if you first met this problem. No one will need those and thus and practice on those algorithm problems in daily work.&lt;/p&gt;

&lt;p&gt;But I think I&amp;rsquo;m wrong, or at least not that accurate on the percentage of characteristic they would like to see from you during the interviews. Let&amp;rsquo;s list what areas we should have as a developer:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;thought process: the way you approach a new problem, and how you solve it&lt;/li&gt;
&lt;li&gt;communication: can you make others clear about your thought&lt;/li&gt;
&lt;li&gt;algorithm and data structure: basically CS knowledge&lt;/li&gt;
&lt;li&gt;coding style: naming, methods, spaces&lt;/li&gt;
&lt;li&gt;result correctness:&lt;/li&gt;
&lt;li&gt;tests cases: how do you want to test your program to ensure it&amp;rsquo;s correct&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I think I put too much weight on 1 and 2 because I thought that&amp;rsquo;s the part that shows how a person works in real world, and whether a person is a good cooperator. But yes, that&amp;rsquo;s my thoughts, or the thoughts from the people I know.&lt;/p&gt;

&lt;p&gt;In a 45 or 60 minute interview, it&amp;rsquo;s hard to express all of the area listed above, which you have to, so how? In my opinion the part I can work on, and improve is the speed of writing coding. &lt;strong&gt;So that I could write code so quickly enough to still keep the time and effort I will use to communicate and explain, to test and walk through the algorithm.&lt;/strong&gt; It&amp;rsquo;s not because it&amp;rsquo;s a mandatory in work (and my friend and I thought it&amp;rsquo;s kind of ridiculous), but it&amp;rsquo;s for the interview to be perfect(无懈可击) (as much as possible) that people won&amp;rsquo;t have something bad to put on their feedbacks.&lt;/p&gt;

&lt;p&gt;Why? because you don&amp;rsquo;t know the interviewers, it&amp;rsquo;s possible some people want perfectness of code, some people think communication and collaboration is the most important thing, while others like to see clean code and meaningful names. The bad thing is that you don&amp;rsquo;t know what they want, so all you can do is give them all.&lt;/p&gt;

&lt;p&gt;This blog comes an action item of my reviews the interview I&amp;rsquo;ve been through. I will keep working on the algorithms as a long lasting background job to write down my journey on this. I will try to dive deep on the algorithms, complexity analysis and do clear explanations.&lt;/p&gt;

&lt;p&gt;You are not guaranteed to succeed, but you are guaranteed not if you don&amp;rsquo;t try. Do my part, and accept the rest.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Create Web</title>
      <link>https://ericliu03.github.io/posts/2019/04/create-web/</link>
      <pubDate>Fri, 05 Apr 2019 09:01:37 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/create-web/</guid>
      <description>

&lt;p&gt;This is technically first post in this blog. I thought it&amp;rsquo;s worth to write down the process of creating this static website.&lt;/p&gt;

&lt;p&gt;I choose to use English as the language in this blog, which might be helpful in future. Or I may switch to Chinese anyway.&lt;/p&gt;

&lt;h2 id=&#34;steps&#34;&gt;Steps&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Searched a little bit in zhihu.com and found this post about &lt;a href=&#34;https://blog.coderzh.com/2015/08/29/hugo/&#34; target=&#34;_blank&#34;&gt;create website using huge&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;quick start with hugo: &lt;a href=&#34;https://gohugo.io/getting-started/quick-start/&#34; target=&#34;_blank&#34;&gt;https://gohugo.io/getting-started/quick-start/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;and hosting on github: &lt;a href=&#34;https://gohugo.io/hosting-and-deployment/hosting-on-github/&#34; target=&#34;_blank&#34;&gt;https://gohugo.io/hosting-and-deployment/hosting-on-github/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It&amp;rsquo;s quite simple to create a simple page, but there sohuld be more features to add later. Let&amp;rsquo;s see if there&amp;rsquo;s any needed, and add them then.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>My First Post</title>
      <link>https://ericliu03.github.io/posts/my-first-post/</link>
      <pubDate>Fri, 05 Apr 2019 08:31:26 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/my-first-post/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
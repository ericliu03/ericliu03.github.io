<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yang&#39;s Blog</title>
    <link>https://ericliu03.github.io/</link>
    <description>Recent content on Yang&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 07 May 2019 10:53:59 -0700</lastBuildDate>
    
        <atom:link href="https://ericliu03.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Leetcode 714] Best Time to Buy and Sell Stock with Transaction Fee</title>
      <link>https://ericliu03.github.io/posts/2019/05/best_time_to_buy_sell_stock_with_fee/</link>
      <pubDate>Tue, 07 May 2019 10:53:59 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/05/best_time_to_buy_sell_stock_with_fee/</guid>
      <description>

&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/&#34;&gt;Leetcode 714: Best Time to Buy and Sell Stock with Transaction Fee&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Your are given an array of integers &lt;code&gt;prices&lt;/code&gt;, for which the &lt;code&gt;i&lt;/code&gt;-th element is the price of a given stock on day &lt;code&gt;i&lt;/code&gt;; and a non-negative integer fee representing a transaction &lt;code&gt;fee&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)&lt;/p&gt;

&lt;p&gt;Return the maximum profit you can make.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note:&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt; prices.length &amp;lt;= 50000&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt; prices[i] &amp;lt; 50000&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= fee &amp;lt; 50000&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: prices = [1, 3, 2, 8, 4, 9], fee = 2
Output: 8
Explanation: The maximum profit can be achieved by:
Buying at prices[0] = 1
Selling at prices[3] = 8
Buying at prices[4] = 4
Selling at prices[5] = 9
The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;method-1&#34;&gt;Method 1&lt;/h3&gt;

&lt;p&gt;On each day, we hold two values represent our profit in two states: if we have cash, or if we hold stock.
cash[i] = max(cash[i-1], hold[i-1] + price[i] - fee)
hold[i] = max(hold[i-1], cash[i-1] - price[i])&lt;/p&gt;

&lt;h4 id=&#34;code&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maxProfit&lt;/span&gt;(self, prices: List[int], fee: int) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
        cash, hold &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;prices[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, len(prices)):
            cash &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(cash, hold &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; prices[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; fee)
            hold &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(hold, cash &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; prices[i])
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; cash&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[Leetcode 552] Student Attendance Record II</title>
      <link>https://ericliu03.github.io/posts/2019/05/student_attendance_record_ii/</link>
      <pubDate>Mon, 06 May 2019 10:54:57 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/05/student_attendance_record_ii/</guid>
      <description>

&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/frog-jump/&#34;&gt;Leetcode 552: Student Attendance Record II&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given a positive integer n, return the number of all possible attendance records with length n, which will be regarded as rewardable. The answer may be very large, return it after mod &lt;code&gt;10^9 + 7&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A student attendance record is a string that only contains the following three characters:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&amp;lsquo;A&amp;rsquo; : Absent.&lt;/li&gt;
&lt;li&gt;&amp;lsquo;L&amp;rsquo; : Late.&lt;/li&gt;
&lt;li&gt;&amp;lsquo;P&amp;rsquo; : Present.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;A record is regarded as rewardable if it doesn&amp;rsquo;t &lt;code&gt;contain more than one &#39;A&#39; (absent)&lt;/code&gt; or &lt;code&gt;more than two continuous &#39;L&#39; (late)&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note:&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;The value of &lt;code&gt;n&lt;/code&gt; won&amp;rsquo;t exceed &lt;code&gt;100,000&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: n = 2
Output: 8 
Explanation:
There are 8 records with length 2 will be regarded as rewardable:
&amp;quot;PP&amp;quot; , &amp;quot;AP&amp;quot;, &amp;quot;PA&amp;quot;, &amp;quot;LP&amp;quot;, &amp;quot;PL&amp;quot;, &amp;quot;AL&amp;quot;, &amp;quot;LA&amp;quot;, &amp;quot;LL&amp;quot;
Only &amp;quot;AA&amp;quot; won&#39;t be regarded as rewardable owing to more than one absent times. 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;method-1&#34;&gt;Method 1&lt;/h3&gt;

&lt;p&gt;为了得到长度为n的所有rewardable的string（定义为f(n))，我们可以从长度n-1的string中加上L和P来得到。但是因为不能存在3个连续的L，所以在所有rewardable且长度为n-1的string中，以LL结尾的我们不能要。如果你觉得长度为n-1且以LL结尾的string数量可以用&lt;code&gt;f(n-3) + LL&lt;/code&gt;来表示就错了，因为f(n-3)包含了以L结尾的string，而以L结尾的是不能链接&lt;code&gt;LL&lt;/code&gt;的，也就是说不会存在于f(n-1）包含的情况中。因此， f(n-1)中以LL结尾的情况就等于f(n-4) + PLL。所以f(n) = f(n-1) * 2 - f(n-4) * 1。&lt;/p&gt;

&lt;p&gt;当我们找到这个transition function之后解法就和fibonacci数列没什么不同了。这题是把两种不同想法混合了起来，1是回溯计算的思想，2是组合&lt;/p&gt;

&lt;h4 id=&#34;code&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;checkRecord&lt;/span&gt;(self, n: int) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
        dp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;]
        m &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, n&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
            dp&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append((&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; dp[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; dp[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;])&lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;m)
        
        r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dp[n]
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, n&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
            r &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; (dp[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; dp[n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;i])

        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; r &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt;m&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>[Leetcode 1039] Minimum Score Triangulation of Polygon</title>
      <link>https://ericliu03.github.io/posts/2019/05/minimum_score_triangulation_of_polygon/</link>
      <pubDate>Sun, 05 May 2019 10:52:39 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/05/minimum_score_triangulation_of_polygon/</guid>
      <description>

&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/frog-jump/&#34;&gt;Leetcode 1039: Minimum Score Triangulation of Polygon&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given &lt;code&gt;N&lt;/code&gt;, consider a convex &lt;code&gt;N&lt;/code&gt;-sided polygon with vertices labelled &lt;code&gt;A[0], A[i], ..., A[N-1]&lt;/code&gt; in clockwise order.&lt;/p&gt;

&lt;p&gt;Suppose you triangulate the polygon into &lt;code&gt;N-2&lt;/code&gt; triangles.  For each triangle, the value of that triangle is the product of the labels of the vertices, and the total score of the triangulation is the sum of these values over all &lt;code&gt;N-2&lt;/code&gt; triangles in the triangulation.&lt;/p&gt;

&lt;p&gt;Return the smallest possible total score that you can achieve with some triangulation of the polygon.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note:&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;3 &amp;lt;= A.length &amp;lt;= 50&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= A[i] &amp;lt;= 100&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: [1,2,3]
Output: 6
Explanation: The polygon is already triangulated, and the score of the only triangle is 6.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: [3,7,4,5]
Output: 144
Explanation: There are two triangulations, with possible scores: 3*7*5 + 4*5*7 = 245, or 3*4*5 + 3*4*7 = 144.  The minimum score is 144.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 3:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: [1,3,1,4,1,5]
Output: 13
Explanation: The minimum score triangulation has score 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;method-1&#34;&gt;Method 1&lt;/h3&gt;

&lt;p&gt;对于一个多边形，无论怎样划分，我们得到一个三角形后便可以计算他的score。与此同时，这个三角形会把这个原本的多边形分成两个新的多边形。那么接下来我们只需要继续计算，直到多边形边长为0，也即不存在新的多边形为止。&lt;/p&gt;

&lt;p&gt;除了划分之外，我们题目的要求是找最小，所以需要scan一遍所有可能的拆分方法，找到最小的那种。由于很多sub problem会遇到很多次，所以我们可以存下中间结果减少计算次数。&lt;/p&gt;

&lt;p&gt;这其实是一个典型的DP问题，因为通过对解法的描述我们可以想到原本的problem被很清晰的分成了两个sub problem。&lt;/p&gt;

&lt;h4 id=&#34;code&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;minScoreTriangulation&lt;/span&gt;(self, A: List[int]) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;memo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;helper(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, len(A)&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, A)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;memo[(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, len(A)&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)]
        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;helper&lt;/span&gt;(self, i, j, A):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i, j) &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;memo:
            self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;memo[(i, j)] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, j):
                s &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[i] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; A[k] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; A[j]
                s &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;helper(i, k, A) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;helper(k, j, A)
                self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;memo[(i, j)] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;memo[(i, j)], s)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;memo[(i, j)]
        &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;method-2&#34;&gt;Method 2&lt;/h3&gt;

&lt;p&gt;如果想用2维数组的方式写DP我们就需要考虑一下数组中每个element需要的前置结果有多少。先从状态转移方程来看
设&lt;code&gt;dp[i][j]&lt;/code&gt;为&lt;code&gt;A[i...j]&lt;/code&gt;包含的所有定点的最小score。那么转移方程为&lt;code&gt;dp[i][j] = min(dp[i][k] + dp[k][j] + score(i,k,j)) (i&amp;lt;k&amp;lt;j)&lt;/code&gt;。每个&lt;code&gt;[i,j]&lt;/code&gt;需要的是&lt;code&gt;[i,k]&lt;/code&gt;和&lt;code&gt;[k,j]&lt;/code&gt;，即&lt;code&gt;dp[i][i-&amp;gt;j]&lt;/code&gt;和&lt;code&gt;dp[i-&amp;gt;j][j]&lt;/code&gt;。换句话说，我们在计算大的多边形的时候，我们必须先把它包含的所有小的多边形计算一边。&lt;/p&gt;

&lt;p&gt;直观来看（如下图所示），需要的是所有在&lt;code&gt;dp[i][j]&lt;/code&gt;左边的和下的。所以计算的时候我们是每次计算一条从左上往右下的对角线，也即&lt;code&gt;[0,0]-&amp;gt;[n-1,n-1]&lt;/code&gt;，&lt;code&gt;[0,1]-&amp;gt;[n-2,n-1]&lt;/code&gt;&amp;hellip;.到&lt;code&gt;[0,n-1]-&amp;gt;[0,n-1]&lt;/code&gt;（本题&lt;code&gt;m = n&lt;/code&gt;）&lt;/p&gt;

&lt;h4 id=&#34;code-1&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;minScoreTriangulation&lt;/span&gt;(self, A: List[int]) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
        dp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; len(A) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(A))] 

        &lt;span style=&#34;color:#75715e&#34;&gt;# number of vertices minus 1 in the sub polygon&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, len(A)):
            &lt;span style=&#34;color:#75715e&#34;&gt;# i is start vertex and j is end vertex&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(A)&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;n):
                j &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; n
                score &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, j):
                    score &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(score, A[i] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; A[k] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; A[j] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; dp[i][k] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; dp[k][j])
                dp[i][j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; score
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dp[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;thoughts&#34;&gt;Thoughts&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;做题时其实想到了recursion，或者说DP的方向，就是选取的建模对象错了。

&lt;ol&gt;
&lt;li&gt;我自己在做题时虽然也想到了要划线，分成两份计算然后求和，但是分法想的是从i到k画一条线，分成了&lt;code&gt;i-&amp;gt;k&lt;/code&gt;和&lt;code&gt;k-&amp;gt;i&lt;/code&gt;两部分，这样带来了很多问题，比如 1)三角形如何划分，我考虑了很多情况。。2）数组中最后一个元素和第一个元素组成的边如何连接等等。&lt;/li&gt;
&lt;li&gt;题目的划分方法是把i到j范围内的点看做多边形所有的定点，与此同时把i-&amp;gt;j作为一条边，再选点k组成三角形&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;感觉是时候系统的看一下DP的总结了：&lt;a href=&#34;http://cppblog.com/menjitianya/archive/2015/10/23/212084.html&#34;&gt;夜深人静写算法（二） - 动态规划&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/u014755255/article/details/51076932&#34;&gt;算法笔记——【动态规划】凸多边形最优三角剖分&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://cppblog.com/menjitianya/archive/2015/10/23/212084.html&#34;&gt;夜深人静写算法（二） - 动态规划&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/Jason-Damon/p/3298172.html&#34;&gt;动态规划&amp;ndash;凸多边形最优三角剖分&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>[Leetcode 807] Max Increase to Keep City Skyline</title>
      <link>https://ericliu03.github.io/posts/2019/05/max_increase_to_keep_city_skyline/</link>
      <pubDate>Fri, 03 May 2019 16:22:13 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/05/max_increase_to_keep_city_skyline/</guid>
      <description>

&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/max-increase-to-keep-city-skyline/&#34;&gt;Leetcode 807: Max Increase to Keep City Skyline&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In a 2 dimensional array grid, each value &lt;code&gt;grid[i][j]&lt;/code&gt; represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well.&lt;/p&gt;

&lt;p&gt;At the end, the &amp;ldquo;skyline&amp;rdquo; when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city&amp;rsquo;s skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example.&lt;/p&gt;

&lt;p&gt;What is the maximum total sum that the height of the buildings can be increased?&lt;/p&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]]
Output: 35
Explanation: 
The grid is:
[ [3, 0, 8, 4], 
  [2, 4, 5, 7],
  [9, 2, 6, 3],
  [0, 3, 1, 0] ]

The skyline viewed from top or bottom is: [9, 4, 8, 7]
The skyline viewed from left or right is: [8, 7, 9, 3]

The grid after increasing the height of buildings without affecting skylines is:

gridNew = [ [8, 4, 8, 7],
            [7, 4, 7, 7],
            [9, 4, 8, 7],
            [3, 3, 3, 3] ]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;notes&#34;&gt;Notes:&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt; grid.length = grid[0].length &amp;lt;= 50&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;All heights &lt;code&gt;grid[i][j]&lt;/code&gt; are in the range &lt;code&gt;[0, 100]&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;All buildings in &lt;code&gt;grid[i][j]&lt;/code&gt; occupy the entire grid cell: that is, they are a &lt;code&gt;1 x 1 x grid[i][j]&lt;/code&gt; rectangular prism.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;method-1&#34;&gt;Method 1&lt;/h3&gt;

&lt;p&gt;本题本身并不难，想要不改变skyline那要求就是对于每个楼，它的高度不能超过他这行和这列的最大值。需要做的就是找出每一行和每一列的最大值，然后求差。&lt;/p&gt;

&lt;h4 id=&#34;code&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maxIncreaseKeepingSkyline&lt;/span&gt;(self, grid: List[List[int]]) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
        row &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [max(row) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; row &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; grid]
        col &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [grid[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;][j] &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(grid[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]))]
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(grid)):
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(grid[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;])):
                col[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(col[j], grid[i][j])
        
        r &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(grid)):
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(grid[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;])):
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; grid[i][j] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; min(col[j], row[i]):
                    r &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; min(col[j], row[i]) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; grid[i][j]
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; r&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;method-2&#34;&gt;Method 2&lt;/h3&gt;

&lt;p&gt;但这个题我想说的点是看到了一个使用了python 语法糖的解法。其中使用了常见的&lt;code&gt;max&lt;/code&gt;, &lt;code&gt;min&lt;/code&gt;, &lt;code&gt;sum&lt;/code&gt;。还使用了我不熟悉的&lt;a href=&#34;https://www.geeksforgeeks.org/python-map-function/&#34;&gt;&lt;code&gt;map&lt;/code&gt;&lt;/a&gt; 和&lt;a href=&#34;https://www.geeksforgeeks.org/zip-in-python/&#34;&gt;&lt;code&gt;zip&lt;/code&gt;&lt;/a&gt;. 简单来说&lt;code&gt;map(func, iter)&lt;/code&gt;就是把iter中的每个元素拿到func中处理一下，生成一个list结果。&lt;code&gt;zip(a,b,c)&lt;/code&gt;是把a b c三个iter中同样位置的元素组合成一个tuple，然后生成一个list, &lt;code&gt;coupled&lt;/code&gt;。还有unzip就是zip的反向操作：&lt;code&gt;zip(*coupled)&lt;/code&gt;(注意这个 *)，生成个list of list出来。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maxIncreaseKeepingSkyline&lt;/span&gt;(self, grid: List[List[int]]) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
    row, col &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; list(map(max, grid)), list(map(max, zip(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;grid)))
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; sum(min(i, j) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; row &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; col) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; sum(map(sum, grid))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们来分析一下这个代码：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;map(max, grid)&lt;/code&gt;是吧grid中的每个元素（也就是作为一行的一个list）求最大，生成的就是每行的最大值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;map(max, zip(*grid))&lt;/code&gt;，和之前一样，只不过先做了一个unzip，就是把grid的n行看做n个元素，然后每个元素的第i个sub元素拿出来，各自组成一个list。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>[Leetcode 683] K Empty Slots</title>
      <link>https://ericliu03.github.io/posts/2019/05/k_empty_slots/</link>
      <pubDate>Fri, 03 May 2019 14:09:47 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/05/k_empty_slots/</guid>
      <description>

&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/k-empty-slots&#34;&gt;Leetcode 683: K Empty Slots&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;There is a garden with &lt;code&gt;N&lt;/code&gt; slots. In each slot, there is a flower. The &lt;code&gt;N&lt;/code&gt; flowers will bloom one by one in&lt;code&gt;N&lt;/code&gt; days. In each day, there will be &lt;strong&gt;exactly&lt;/strong&gt; one flower blooming and it will be in the status of blooming since then.&lt;/p&gt;

&lt;p&gt;Given an array &lt;code&gt;flowers&lt;/code&gt; consists of number from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;N&lt;/code&gt;. Each number in the array represents the place where the flower will open in that day.&lt;/p&gt;

&lt;p&gt;For example, &lt;code&gt;flowers[i] = x&lt;/code&gt; means that the unique flower that blooms at day i will be at position &lt;code&gt;x&lt;/code&gt;, where &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt; will be in the range from &lt;code&gt;1&lt;/code&gt; to &lt;code&gt;N&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Also given an integer &lt;code&gt;k&lt;/code&gt;, you need to output in which day there exists two flowers in the status of blooming, and also the number of flowers between them is &lt;code&gt;k&lt;/code&gt; and these flowers are not blooming.&lt;/p&gt;

&lt;p&gt;If there isn&amp;rsquo;t such day, output &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note:&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;The given array will be in the range &lt;code&gt;[1, 20000]&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在reference 1 中有人提到提示题目有两个条件没有说明：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;flowers[i] = x should mean that the unique flower that blooms at day i+1 (not i) will be at position x.&lt;/li&gt;
&lt;li&gt;If you can get multiple possible results, then you need to return the minimum one.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: 
flowers: [1,3,2]
k: 1
Output: 2
Explanation: In the second day, the first and the third flower have become blooming.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: 
flowers: [1,2,3]
k: 1
Output: -1
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;method-1&#34;&gt;Method 1&lt;/h3&gt;

&lt;p&gt;既然每天都会开花，那么我们可以开一个数组&lt;code&gt;slots&lt;/code&gt;来存当前位置的花的开放情况，然后每天扫一遍这个数组来看看符合要求的情况有没有出现。&lt;/p&gt;

&lt;p&gt;时间复杂度为O(n2)的，因为对于每一天都需要扫一遍所有的花。&lt;/p&gt;

&lt;h4 id=&#34;code&#34;&gt;Code&lt;/h4&gt;

&lt;p&gt;代码大概写了一下没有优化，在LC是TLE的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;kEmptySlots&lt;/span&gt;(self, flowers: List[int], k: int) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
        
        slots &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [False] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; len(flowers)
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i, lo &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; enumerate(flowers):
            slots[lo&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; True
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;helper(slots, k):
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;helper&lt;/span&gt;(self, slots, k):
        slow &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
        fast &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
        count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; fast &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len(slots) &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; slots[fast]:
            fast &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        slow &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fast
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; fast &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len(slots):
            non_bloomed &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fast &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; slow &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; non_bloomed &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; k:
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; True
            slow &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; fast
            fast &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; fast &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len(slots) &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; slots[fast]:
                fast &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; False
            &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;method-2&#34;&gt;Method 2&lt;/h3&gt;

&lt;p&gt;既然给定的要求是基于位置（相距k朵花），那么我们就不难想到把提供的信息换一种方式储存：给的array&lt;code&gt;flowers&lt;/code&gt;是第&lt;code&gt;i&lt;/code&gt;天开花的位置&lt;code&gt;l&lt;/code&gt;，我们转换一下变成另一个数组&lt;code&gt;slots&lt;/code&gt;where第&lt;code&gt;l&lt;/code&gt;个位置存的是开花的时间&lt;code&gt;i&lt;/code&gt;。（这个转换有点像inverted index，倒排索引，后面可以研究一下）。基于这个数组我们需要的找的就是&lt;strong&gt;长度为k+2的subarray&lt;/strong&gt;。我们定义这个subarray边界是&lt;code&gt;slots[left]&lt;/code&gt;和&lt;code&gt;slots[right]&lt;/code&gt;，那么题目的要求就是对于 &lt;code&gt;slots[i] where left &amp;lt; i &amp;lt; right&lt;/code&gt;, &lt;code&gt;slots[i] &amp;lt; slots[left] and slots[i] &amp;lt; slots[right]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;关于扫描的方法，我这里使用了从ref1中给出的方法。每当遇到slot[i]比left或者right还小，就把这个作为left。原因是这个slot开花的日子比left或者right开花的日子早，所以不能在subarray中间。（感觉有点马拉车算法的意思？）&lt;/p&gt;

&lt;h4 id=&#34;code-1&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;kEmptySlots&lt;/span&gt;(self, flowers: List[int], k: int) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
        slots &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; len(flowers)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; day, slot &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; enumerate(flowers):
            slots[slot&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; day &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        
        left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
        right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;)
        i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len(slots) &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len(slots):
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; slots[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; slots[left] &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; slots[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; slots[right]:
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; right:
                    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(result, max(slots[left], slots[right]))
                left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i
                right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; k &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
            i &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; result&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;thoughts&#34;&gt;Thoughts&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;有一点想错了，以为两朵花之间有k个没开的，其中可能夹杂着开了的花。而实际上是有k朵花，然后他们都没开。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;reference&#34;&gt;Reference&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/k-empty-slots/discuss/107931/JavaC%2B%2B-Simple-O(n)-solution&#34;&gt;[Java/C++] Simple O(n) solution&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%80%92%E6%8E%92%E7%B4%A2%E5%BC%95&#34;&gt;倒排索引&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://ericliu03.github.io/about/</link>
      <pubDate>Wed, 01 May 2019 17:57:04 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/about/</guid>
      <description>&lt;p&gt;This is a test about.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>[Leetcode 403] Frog Jump</title>
      <link>https://ericliu03.github.io/posts/2019/05/frog_jump/</link>
      <pubDate>Wed, 01 May 2019 16:44:51 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/05/frog_jump/</guid>
      <description>

&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/frog-jump/&#34;&gt;Leetcode 403: Frog Jump&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A frog is crossing a river. The river is divided into x units and at each unit there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.&lt;/p&gt;

&lt;p&gt;Given a list of stones&amp;rsquo; positions (in units) in sorted ascending order, determine if the frog is able to cross the river by landing on the last stone. Initially, the frog is on the first stone and assume the first jump must be 1 unit.&lt;/p&gt;

&lt;p&gt;If the frog&amp;rsquo;s last jump was k units, then its next jump must be either k - 1, k, or k + 1 units. Note that the frog can only jump in the forward direction.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note:&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;The number of stones is ≥ 2 and is &amp;lt; 1,100.&lt;/li&gt;
&lt;li&gt;Each stone&amp;rsquo;s position will be a non-negative integer &amp;lt; 231.&lt;/li&gt;
&lt;li&gt;The first stone&amp;rsquo;s position is always 0.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[0,1,3,5,6,8,12,17]

There are a total of 8 stones.
The first stone at the 0th unit, second stone at the 1st unit,
third stone at the 3rd unit, and so on...
The last stone at the 17th unit.

Return true. The frog can jump to the last stone by jumping 
1 unit to the 2nd stone, then 2 units to the 3rd stone, then 
2 units to the 4th stone, then 3 units to the 6th stone, 
4 units to the 7th stone, and 5 units to the 8th stone.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[0,1,2,3,4,8,9,11]

Return false. There is no way to jump to the last stone as 
the gap between the 5th and 6th stone is too large.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;method-1&#34;&gt;Method 1&lt;/h3&gt;

&lt;p&gt;At first glance this question reminds me &lt;a href=&#34;https://github.com/ericliu03/blog.io/blob/master/content/posts/2019/04/longest_increasing_subsequence.md&#34;&gt;longest increasing subsequence&lt;/a&gt;. We can translate the stones into the vertices in the graph and then what we need to find out are the edges and whether there&amp;rsquo;s a path between start and end vertex.&lt;/p&gt;

&lt;p&gt;At each vertex, to calculate the edges to next vertices, we will use the rule given by the question: &lt;em&gt;the difference between previous vertex and current vertex (plus -1, 0, 1)&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Since we start from the start stone, so if there&amp;rsquo;s any vertex that&amp;rsquo;s connected to the end vertex then it means we find a path.&lt;/p&gt;

&lt;h4 id=&#34;code&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;canCross&lt;/span&gt;(stones) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; bool:
    &lt;span style=&#34;color:#75715e&#34;&gt;# jump sizes are the distance between previous stone to current stone&lt;/span&gt;
    jump_sizes &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; stone &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; stones:
        jump_sizes[stone] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set()
        
    jump_sizes[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; stone &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; stones:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; jump_size &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; jump_sizes[stone]:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; delta &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; (&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
                next_jump &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; jump_size &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; delta
                &lt;span style=&#34;color:#75715e&#34;&gt;# we use the distance between prev and curr stone to calculate next stone&lt;/span&gt;
                &lt;span style=&#34;color:#75715e&#34;&gt;# and add this new jump size to it&amp;#39;s jump size set if next stone exists&lt;/span&gt;
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; stone &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; next_jump &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; jump_sizes &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; next_jump &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
                    jump_sizes[stone &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; next_jump]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add(next_jump)

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; len(jump_sizes[stones[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]]) &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;thoughts&#34;&gt;Thoughts&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;the information stored could be in different formats, such as

&lt;ol&gt;
&lt;li&gt;previous stone&amp;rsquo;s location&lt;/li&gt;
&lt;li&gt;jump distances used to jump to this stone (the one i chose)&lt;/li&gt;
&lt;li&gt;jump distances could be used in this stone to next stones&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Escape A Large Maze</title>
      <link>https://ericliu03.github.io/posts/2019/04/escape_a_large_maze/</link>
      <pubDate>Mon, 29 Apr 2019 16:43:38 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/escape_a_large_maze/</guid>
      <description>

&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/escape-a-large-maze/&#34;&gt;Leetcode 1036: Escape a Large Maze&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In a 1 million by 1 million grid, the coordinates of each grid square are &lt;code&gt;(x, y)&lt;/code&gt; with &lt;code&gt;0 &amp;lt;= x, y &amp;lt; 10^6&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We start at the &lt;code&gt;source&lt;/code&gt; square and want to reach the &lt;code&gt;target&lt;/code&gt; square.  Each move, we can walk to a 4-directionally adjacent square in the grid that isn&amp;rsquo;t in the given list of &lt;code&gt;blocked&lt;/code&gt; squares.&lt;/p&gt;

&lt;p&gt;Return &lt;code&gt;true&lt;/code&gt; if and only if it is possible to reach the target square through a sequence of moves.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note:&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= blocked.length &amp;lt;= 200&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;blocked[i].length == 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= blocked[i][j] &amp;lt; 10^6&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source.length == target.length == 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= source[i][j], target[i][j] &amp;lt; 10^6&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;source != target&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]
Output: false
Explanation: 
The target square is inaccessible starting from the source square, because we can&#39;t walk outside the grid.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: blocked = [], source = [0,0], target = [999999,999999]
Output: true
Explanation: 
Because there are no blocked cells, it&#39;s possible to reach the target square.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;method-1&#34;&gt;Method 1&lt;/h3&gt;

&lt;p&gt;We can do a DFS or BFS from start to see if target could be reached. But this will TLE since the matrix is too large.&lt;/p&gt;

&lt;h3 id=&#34;method-2&#34;&gt;Method 2&lt;/h3&gt;

&lt;p&gt;After taking a closer look at the &amp;ldquo;Notes&amp;rdquo;, you will be able to find the &lt;strong&gt;key point&lt;/strong&gt; of this question: &lt;code&gt;0 &amp;lt;= blocked.length &amp;lt;= 200&lt;/code&gt;. This means there are only at maximum &lt;code&gt;200&lt;/code&gt; blocked in the matrix and &lt;code&gt;200&lt;/code&gt; is a small number comparing to &lt;code&gt;10^6&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This graph from reference 1 shows the insight: the maximum area that those blocked grid can enclose is &lt;code&gt;1+2+3+4+5+...+198+199=(1+199)*199/2=19900&lt;/code&gt; (trapezoid sum)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0th      ______________________  200
         |------------------ X            
         |---------------- X
         .              .
         .           .
         .        . 
         | -  - X 
         | - X
200      |X
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then there are conditions:
1. there is not an enclosed area
1. there is an enclosed area
 1. source is inside, target is out
 1. target is in, source is out
 1. both in or both out&lt;/p&gt;

&lt;p&gt;In order to cover all conditions, we run bfs/dfs from both source and target, so if
1. they find each other, return true
1. if none of them is in enclosed area, return true
1. otherwise return false&lt;/p&gt;

&lt;h4 id=&#34;code&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;isEscapePossible&lt;/span&gt;(blocked, source, target):
    max_area &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ((&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;199&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;199&lt;/span&gt;)&lt;span style=&#34;color:#f92672&#34;&gt;//&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;
    n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;
    visited &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set([tuple(each) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; each &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; blocked])
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;bfs&lt;/span&gt;(start, end):
        queue &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [tuple(start)]
        visited&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add(tuple(start))
        count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x0, y0 &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; queue:
            count &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (x0, y0) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; end:
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; True
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; count &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; max_area:
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; True
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x, y &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; [(&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;), (&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;), (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;), (&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)]:
                next_node &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (x0&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;x, y0&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;y)
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; next_node &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; visited &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; next_node[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; next_node[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n:
                    queue&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(next_node)
                    visited&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add(next_node)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; False

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; bfs(target, source) &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; bfs(source, target)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;thoughts&#34;&gt;Thoughts&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;don&amp;rsquo;t neglect the constraints&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Uncrossed Lines</title>
      <link>https://ericliu03.github.io/posts/2019/04/uncrossed_lines/</link>
      <pubDate>Sun, 28 Apr 2019 10:46:05 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/uncrossed_lines/</guid>
      <description>

&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/uncrossed-lines/&#34;&gt;Leetcode 1035: Uncrossed Lines&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We write the integers of &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; (in the order they are given) on two separate horizontal lines.&lt;/p&gt;

&lt;p&gt;Now, we may draw a straight line connecting two numbers &lt;code&gt;A[i]&lt;/code&gt; and &lt;code&gt;B[j]&lt;/code&gt; as long as &lt;code&gt;A[i] == B[j]&lt;/code&gt;, and the line we draw does not intersect any other connecting (non-horizontal) line.&lt;/p&gt;

&lt;p&gt;Return the maximum number of connecting lines we can draw in this way.&lt;/p&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;1 4 2
|  \
1 2 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: A = [1,4,2], B = [1,2,4]
Output: 2
Explanation: We can draw 2 uncrossed lines as in the diagram.
We cannot draw 3 uncrossed lines, 
because the line from A[1]=4 to B[2]=4 will intersect the line from A[2]=2 to B[1]=2.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: A = [2,5,1,2,5], B = [10,5,2,1,5,2]
Output: 3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 3:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: A = [1,3,7,1,7,5], B = [1,9,2,5,1]
Output: 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;note&#34;&gt;Note:&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;1 &amp;lt;= A.length &amp;lt;= 500&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= B.length &amp;lt;= 500&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= A[i], B[i] &amp;lt;= 2000&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;method-1-错误想法&#34;&gt;Method 1 （错误想法）&lt;/h3&gt;

&lt;p&gt;这个题最直接的想法就是使用recursion来遍历，可能会想到下面这种解法：对于A中每一个数字&lt;code&gt;i&lt;/code&gt;，for loop B找到其中一样的那些数字&lt;code&gt;j&lt;/code&gt;。对于每个match的&lt;code&gt;i，j&lt;/code&gt;，找到他们之后的，也就是&lt;code&gt;A[i+1:]&lt;/code&gt;和&lt;code&gt;B[j+1:]&lt;/code&gt;能最多match的数量。这种方法有一个问题就是把for loop和recursion的思想混用了，会大大提高把自己绕晕的概率。。。&lt;/p&gt;

&lt;h3 id=&#34;method-2&#34;&gt;Method 2&lt;/h3&gt;

&lt;p&gt;我们上述recursion的定义是对于从i, j开始的A，B，最多match的数量，我们可以写作&lt;code&gt;longest_match(i, j, A, B)&lt;/code&gt;。那么有两种情况：1）&lt;code&gt;A[i] == B[j]&lt;/code&gt;, 所以&lt;code&gt;longest_match(i, j, A, B)&lt;/code&gt; 结果之一等于 &lt;code&gt;longest_match(i+1, j+1, A, B)&lt;/code&gt; + 1（因为现在多match了一个）。2）不相等，两种子情况就是&lt;code&gt;longest_match(i+1, j, A, B)&lt;/code&gt; 和&lt;code&gt;longest_match(i, j+1, A, B)&lt;/code&gt;。这三种情况都考虑到，也就意味着所有的可能性都考虑到了，只是我们返回结果时值保留了最大的那种情况的数字。回过头来看上面带forloop的方法，就做了很多重复运算了。&lt;/p&gt;

&lt;h3 id=&#34;method-3&#34;&gt;Method 3&lt;/h3&gt;

&lt;p&gt;方法2依然存在一些重复运算，比如 当然是&lt;code&gt;i,j&lt;/code&gt;,我们需要拿到&lt;code&gt;i+1,j+1&lt;/code&gt;，&lt;code&gt;i+1,j&lt;/code&gt;和&lt;code&gt;i,j+1&lt;/code&gt;，那么到了&lt;code&gt;i+1,j&lt;/code&gt;时，我们需要拿到&lt;code&gt;i+2,j+1&lt;/code&gt;，&lt;code&gt;i+1,j+1&lt;/code&gt;和&lt;code&gt;i+2,j&lt;/code&gt;。所以可以使用DP：1）用memo存中间结果，2）用DP数组直接算结果。（&lt;a href=&#34;https://ericliu03.github.io/posts/2019/04/longest_increasing_subsequence/&#34;&gt;关于从recursion到DP的文章&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;关于输出序列可以参考ref 3和4.&lt;/p&gt;

&lt;p&gt;本题其实就是&lt;a href=&#34;https://www.google.com/search?newwindow=1&amp;amp;q=longest+common+subsequence&#34;&gt;longest common subsequence&lt;/a&gt;。&lt;/p&gt;

&lt;h4 id=&#34;code&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maxUncrossedLines&lt;/span&gt;(A, B):
    dp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (len(B)&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(A)&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)]
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, len(A) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; j &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, len(B) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
            dp[i][j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dp[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][j&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; A[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; B[j&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
            dp[i][j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(dp[i][j], dp[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][j], dp[i][j&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; dp[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;][&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;thoughts&#34;&gt;Thoughts&lt;/h2&gt;

&lt;p&gt;对比最简单的DP，比如&lt;a href=&#34;https://leetcode.com/problems/climbing-stairs/&#34;&gt;爬梯子&lt;/a&gt;，我想错的地方（method1）就是对于每个&lt;code&gt;i&lt;/code&gt;我需要loop所有&lt;code&gt;j&lt;/code&gt;，然后再recursion，没有想清楚recursion的输入输出是什么，也就是转移方程是什么。就像梯子题，对于&lt;code&gt;i&lt;/code&gt;，我只需要看&lt;code&gt;i-1&lt;/code&gt;和&lt;code&gt;i-2&lt;/code&gt;，具体到第&lt;code&gt;i-1&lt;/code&gt;阶的时候有多少种可能性， 都是怎么来的不care。题目规定只能从那两个地方过来，但是本题没有这种明显的规定，需要想清楚&lt;code&gt;i,j&lt;/code&gt;只能从那3个地方过来，而不是可以从所有j过来。&lt;/p&gt;

&lt;p&gt;有一点令我耿耿于怀的就是&lt;code&gt;i,j&lt;/code&gt;只能从&lt;code&gt;i+1,j+1&lt;/code&gt;，&lt;code&gt;i+1,j&lt;/code&gt;和&lt;code&gt;i,j+1&lt;/code&gt;这三个地方过来，那如果如果我是一个&lt;code&gt;A[i]&lt;/code&gt;和B&lt;code&gt;[j+100]&lt;/code&gt;match怎么办，看着好像没考虑进去。但实际上是算在里面了的，因为&lt;code&gt;i,j&lt;/code&gt;可以到&lt;code&gt;i,j+1&lt;/code&gt;，&lt;code&gt;i,j+1&lt;/code&gt;也考虑到了&lt;code&gt;i, j+2&lt;/code&gt;的情况。所以在&lt;code&gt;i,j&lt;/code&gt;的位置上，我们看&lt;code&gt;i,j+1&lt;/code&gt;的时候就已经包含了&lt;code&gt;i,j+100&lt;/code&gt;的情况。如果这种情况match的最多，那么就是被保留下来的那一个。只不过在结果中我们不知道到底是match到了&lt;code&gt;j+?&lt;/code&gt;。想要知道的话还需要回溯去找出他们。&lt;/p&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Longest_common_subsequence_problem&#34;&gt;wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.geeksforgeeks.org/longest-common-subsequence-dp-4/&#34;&gt;Longest Common Subsequence | DP-4&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/qq_36368339/article/details/76944448&#34;&gt;LCS+路径还原&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://songlee24.github.io/2014/11/29/print-all-LCS/&#34;&gt;【动态规划】输出所有的最长公共子序列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Coloring Border</title>
      <link>https://ericliu03.github.io/posts/2019/04/coloring_a_border/</link>
      <pubDate>Sun, 28 Apr 2019 09:42:03 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/coloring_a_border/</guid>
      <description>

&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/coloring-a-border/&#34;&gt;Leetcode 1034: Coloring A Border&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given a 2-dimensional grid of integers, each value in the &lt;code&gt;grid&lt;/code&gt; represents the color of the grid square at that location.&lt;/p&gt;

&lt;p&gt;Two squares belong to the same connected component if and only if they have the same color and are next to each other in any of the 4 directions.&lt;/p&gt;

&lt;p&gt;The border of a connected component is all the squares in the connected component that are either 4-directionally adjacent to a square not in the component, or on the boundary of the grid (the first or last row or column).&lt;/p&gt;

&lt;p&gt;Given a square at location &lt;code&gt;(r0, c0)&lt;/code&gt; in the grid and a &lt;code&gt;color&lt;/code&gt;, &lt;code&gt;color&lt;/code&gt; the border of the connected component of that square with the given &lt;code&gt;color&lt;/code&gt;, and return the final grid.&lt;/p&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: grid = [[1,1],[1,2]], r0 = 0, c0 = 0, color = 3
Output: [[3, 3], [3, 2]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: grid = [[1,2,2],[2,3,2]], r0 = 0, c0 = 1, color = 3
Output: [[1, 3, 3], [2, 3, 3]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 3:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: grid = [[1,1,1],[1,1,1],[1,1,1]], r0 = 1, c0 = 1, color = 2
Output: [[2, 2, 2], [2, 1, 2], [2, 2, 2]]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;notes&#34;&gt;Notes:&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= grid.length &amp;lt;= 50&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= grid[0].length &amp;lt;= 50&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= grid[i][j] &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= r0 &amp;lt; grid.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= c0 &amp;lt; grid[0].length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= color &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;method-1&#34;&gt;Method 1&lt;/h3&gt;

&lt;p&gt;Use regular dfs/bfs to find the border squares and change them.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;There are two things needs to know 1) if current square is in original component, 2) if current square is border&lt;/li&gt;
&lt;li&gt;I used &lt;code&gt;1/0&lt;/code&gt; to indicate if a square is in original component, so by adding up dfs result from four adjacent squares, we know whether current one is border or not.&lt;/li&gt;
&lt;li&gt;the &lt;strong&gt;grid should not be changed&lt;/strong&gt; while doing dfs/bfs.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;code&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;colorBorder&lt;/span&gt;(self, grid, r0, c0, color):

        visited &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set()
        border &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set()

        &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dfs&lt;/span&gt;(x, y):
            &lt;span style=&#34;color:#75715e&#34;&gt;# if current square is in original component, return 1, otherwise 0&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len(grid) &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; y &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len(grid[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]) &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; grid[x][y] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; grid[r0][c0]:
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (x, y) &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; visited:
                    visited&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add((x, y))
                    &lt;span style=&#34;color:#75715e&#34;&gt;# if one of the adjacent square is not in the component, then this square is border&lt;/span&gt;
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; dfs(x &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, y) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; dfs(x &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, y) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; dfs(x, y &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; dfs(x, y &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;:
                        border&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add((x, y))
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;

        dfs(r0, c0)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; x, y &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; border:
            grid[x][y] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; color
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; grid&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Two Pass for Min/Max/Sum/Product</title>
      <link>https://ericliu03.github.io/posts/2019/04/two_pass/</link>
      <pubDate>Tue, 23 Apr 2019 21:23:24 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/two_pass/</guid>
      <description>

&lt;p&gt;今天我们讲解一种算法思想。这种方法一般使用在需要把整个数组分成2份的情况，求这两份组成的是最大、最小、和最大之类的。下面我们来看三道由易到难的题目。&lt;/p&gt;

&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/product-of-array-except-self&#34;&gt;Leetcode 238: Product of Array Except Self&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given an array &lt;code&gt;nums&lt;/code&gt; of n integers where n &amp;gt; 1,  return an array &lt;code&gt;output&lt;/code&gt; such that &lt;code&gt;output[i]&lt;/code&gt; is equal to the product of all the elements of &lt;code&gt;nums&lt;/code&gt; except &lt;code&gt;nums[i]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Input:  [1,2,3,4]
Output: [24,12,8,6]
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;follow-up&#34;&gt;Follow up:&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;Please solve it without division and in O(n).&lt;/li&gt;
&lt;li&gt;Could you solve it with constant space complexity? (The output array does not count as extra space for the purpose of space complexity analysis.)&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;method-1&#34;&gt;Method 1&lt;/h3&gt;

&lt;p&gt;求全部数字的乘积&lt;code&gt;mul&lt;/code&gt;，然后生成output的时候把&lt;code&gt;mul&lt;/code&gt;除以当前数字就是结果。time complexity是O(n)，但是用到了除法。&lt;/p&gt;

&lt;h3 id=&#34;method-2&#34;&gt;Method 2&lt;/h3&gt;

&lt;p&gt;为了不用除法我们可以对每个数字都遍历一边他左边和右边的数字求乘积，但是是O(n2)。&lt;/p&gt;

&lt;h3 id=&#34;method-3&#34;&gt;Method 3&lt;/h3&gt;

&lt;p&gt;我们扫两遍数组，计算出两个数组&lt;code&gt;left[i]&lt;/code&gt; 和 &lt;code&gt;right[i]&lt;/code&gt;，分别是从0到i和从i到n-1的累积乘积。在计算结果时对于每个数计算&lt;code&gt;left[i-1]*right[i+1]&lt;/code&gt;即可。没有使用除法，也是O(n)。但是用了O(n)的space&lt;/p&gt;

&lt;h3 id=&#34;method-4&#34;&gt;Method 4&lt;/h3&gt;

&lt;p&gt;既然output不算做extra space，那么我们可以利用他当做left，然后在计算right数组的同时计算结果。这样就满足了所有follow up 条件。&lt;/p&gt;

&lt;h4 id=&#34;code&#34;&gt;Code&lt;/h4&gt;

&lt;p&gt;我们这里只写method 4 的code了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;productExceptSelf&lt;/span&gt;(nums):
    left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
    
    curr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(nums)):
        curr &lt;span style=&#34;color:#f92672&#34;&gt;*=&lt;/span&gt; nums[i]
        left&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(curr)
    
    curr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(nums)&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;,&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;):
        left[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left[i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; curr
        curr &lt;span style=&#34;color:#f92672&#34;&gt;*=&lt;/span&gt; nums[i]
    left[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; curr
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; left&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;question-2&#34;&gt;Question 2&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/trapping-rain-water/&#34;&gt;Leetcode 42: Trapping Rain Water&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;&lt;img class=&#34;special-img-class&#34; style=&#34;width:50%&#34; src=&#34;https://ericliu03.github.io/img/monotone_stack_img2.png&#34; /&gt;
The above elevation map is represented by array &lt;code&gt;T=[0,1,0,2,1,0,1,3,2,1,2,1]&lt;/code&gt;. In this case, 6 units of rain water (blue section) are being trapped.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-1&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;method-1-1&#34;&gt;Method 1&lt;/h3&gt;

&lt;p&gt;这题我们之前在monotone stack中讲解了一种解法，我们这次来看two pass如何使用在这道题上。&lt;/p&gt;

&lt;p&gt;从题目出发，我们需要找出每个点上可以存的水的数量（高度），能存多高取决于这个点左右两边最高的高度，也就是边界高度。但是相邻的左右两个点未必是其边界，我们需要找左右两边的最高的高度。所以我们可以扫描两边数组，找出对于位置&lt;code&gt;i&lt;/code&gt;左边的和右边的最高的elevation的高度。&lt;/p&gt;

&lt;h4 id=&#34;code-1&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;trap&lt;/span&gt;(heights):
    n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len(heights)
    left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; n
    l_max &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r_max &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n):
        l_max &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(l_max, heights[i])
        r_max &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(r_max, heights[n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; i])
        left[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; l_max
        right[n&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; r_max
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n):
        water &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(left[i], right[i]) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; heights[i]
        result &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; water &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; water &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;question-3&#34;&gt;Question 3&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/&#34;&gt;Leetcode 1031: Maximum Sum of Two Non-Overlapping Subarrays&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given an array A of non-negative integers, return the maximum sum of elements in two non-overlapping (contiguous) subarrays, which have lengths L and M.  (For clarification, the L-length subarray could occur before or after the M-length subarray.)&lt;/p&gt;

&lt;p&gt;Formally, return the largest V for which &lt;code&gt;V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1])&lt;/code&gt;and either:&lt;code&gt;0 &amp;lt;= i &amp;lt; i + L - 1 &amp;lt; j &amp;lt; j + M - 1 &amp;lt; A.length&lt;/code&gt;, or &lt;code&gt;0 &amp;lt;= j &amp;lt; j + M - 1 &amp;lt; i &amp;lt; i + L - 1 &amp;lt; A.length&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;examples-1&#34;&gt;Examples:&lt;/h3&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2
Output: 20
Explanation: One choice of subarrays is [9] with length 1, and [6,5] with length 2.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2
Output: 29
Explanation: One choice of subarrays is [3,8,1] with length 3, and [8,9] with length 2.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 3:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: A = [2,1,5,6,0,9,5,0,3,8], L = 4, M = 3
Output: 31
Explanation: One choice of subarrays is [5,6,0,9] with length 4, and [3,8] with length 3.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-2&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;method-1-2&#34;&gt;Method 1&lt;/h3&gt;

&lt;p&gt;题目形容的有点难懂，简单来说就是在给的array中找出两个不重叠的长度为L和M的subsequence，他们的和最大。L和M的两个subsequence元素的加入让题目复杂了一些，但是仔细一想两个不重叠的subsequence，其实也可以看做是在&lt;code&gt;index = i&lt;/code&gt;处的左右两边的两个数组。那么这样理解之后解法其实就与上面的题目一样了，只是元素多了一点：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;我们从左往右，找出在每个点&lt;code&gt;i&lt;/code&gt;处，左边为L长度和左边为M长度的最大值，放在两个数组里。&lt;/li&gt;
&lt;li&gt;再从右往左，找出左边为M和左边为L长度的放到另外两个数组中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;代码可以参考一下&lt;a href=&#34;https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/discuss/278727/C%2B%2B-O(N)-buysell-stock-2-times&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;method-2-1&#34;&gt;Method 2&lt;/h3&gt;

&lt;p&gt;虽然method 1我们存了4个数组出来，但其实和Q1M3的解法是相同的。下面我们做一些类似于Q1M4一样的优化。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;和Q1M4一样，在第二遍从右往左扫描时直接计算结果。（节省一半储存和计算结果的一遍扫描）&lt;/li&gt;
&lt;li&gt;不算最大值，算cumulative sum。subsequence的sum直接使用减法计算&lt;code&gt;sum_left_to_right = A[left] - A[right]&lt;/code&gt;。最大值在扫描时计算。（再节省一半储存）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;因为题目的特性，我们可以在第二遍依然从左往右走，不断update两个变量l_left, m_left,分别为左边长度为l和m的sequence的sum的最大值。扫描的同时计算出每一个A[i-L]和A[i-M]的值，作为右边对应的长度为M和L的值。求和即为可能结果，因为左边是max，右边又扫描到了每一个长度为L和M的sum
，所以最大的和一定就是结果。&lt;/p&gt;

&lt;h4 id=&#34;code-2&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maxSumTwoNoOverlap&lt;/span&gt;(A, L, M):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, len(A)):
        A[i] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; A[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]

    l_left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[L &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
    m_left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[M &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[L &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; M &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(L &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; M, len(A)):
        l_left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(l_left, A[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; M] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; A[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; M &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; L])
        m_left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(m_left, A[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; L] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; A[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; L &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; M])

        l_right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; A[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; L]
        m_right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; A[i] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; A[i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; M]

        result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(result, l_left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; m_right, m_left &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; l_right)

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;summary&#34;&gt;Summary&lt;/h2&gt;

&lt;p&gt;总的来说这个解法就是对给定的数据做一些预处理，然后在处理之后的数据上求需要的结果。&lt;/p&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;more questions:

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/&#34;&gt;Leetcode 123: Best Time to Buy and Sell Stock III&lt;/a&gt;, &lt;a href=&#34;https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/discuss/39665/Java-solution-with-just-two-traverses.&#34;&gt;solution&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/discuss/278727/C%2B%2B-O(N)-buysell-stock-2-times&#34;&gt;Q3解法1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/maximum-sum-of-two-non-overlapping-subarrays/discuss/278251/JavaC%2B%2BPython-O(N)Time-O(1)-Space&#34;&gt;Q3解法2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/grandyang/p/4402392.html&#34;&gt;[LeetCode] Trapping Rain Water 收集雨水&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Monotone Stack</title>
      <link>https://ericliu03.github.io/posts/2019/04/monotone_stack/</link>
      <pubDate>Fri, 19 Apr 2019 12:45:10 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/monotone_stack/</guid>
      <description>

&lt;p&gt;今天我们的题目会围绕一种数据结构（单调栈）和相应的解题方法来讲解。总共3道由易到难的题目。&lt;/p&gt;

&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/daily-temperatures/&#34;&gt;Leetcode 739: Daily Temperatures&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature. If there is no future day for which this is possible, put 0 instead.&lt;/p&gt;

&lt;h3 id=&#34;example&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;given the list of temperatures &lt;code&gt;T = [73, 74, 75, 71, 69, 72, 76, 73]&lt;/code&gt;, your output should be &lt;code&gt;[1, 1, 4, 2, 1, 1, 0, 0]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;p&gt;The length of temperatures will be in the range &lt;code&gt;[1, 30000]&lt;/code&gt;. Each temperature will be an integer in the range &lt;code&gt;[30, 100]&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;method-1&#34;&gt;Method 1&lt;/h3&gt;

&lt;h4 id=&#34;analysis&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;这题去掉context就是找每个数的下一个比他大的数的位置。\( O(N^2) \) 的方法就简单说一下：对于每个数，都扫一遍他后面的所有数，找到第一个比他大的。&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;special-img-class&#34; style=&#34;width:50%&#34; src=&#34;https://ericliu03.github.io/img/monotone_stack_img1.jpeg&#34; /&gt;&lt;/p&gt;

&lt;p&gt;那更快一点的方法呢？我们现在考虑如上图两种情况， 1中在a之前的点是单调递增的，所以对于每个数来说，下一个比他大的数就是他右边的数。假设b比a大，那么对于点a来说只有到了b点才能知道下一个大的数在哪。所以我们可以先把a存起来，直到遇到了比a大的b，再写到结果里说比a大的是b。对于图2，在b之前是单调递减的，所以直到b之前都不会遇到符合条件的数，所以我们都得存下来，等遇到b了，我们就可以把存下来的数中比b小的放到结果中，比b大的依然要等。&lt;/p&gt;

&lt;p&gt;那么用什么数据结构来暂存这些数呢？关键点就是这些暂存的数字需要保持进入时的顺序，先进先出。所以我们用一个stack来存下暂时没有找到更大的数的数，每当来一个新数的时候就和stack中的数字比较一下，如果新数比stack的顶要大，那就说明栈顶的数的对应的数找到了，可以写入结果了。我们就把他pop出来，继续看栈顶，直到栈为空或者栈顶的数比新数大。可以看到这个stack里面的数单调递减的，原因是如果有increase的话，比如&lt;code&gt;a&amp;gt;b&amp;lt;c&lt;/code&gt;，那么b的答案其实就是c，一开始就不会放到stack里。&lt;/p&gt;

&lt;p&gt;这就是monotone stack，&lt;a href=&#34;http://www.cnblogs.com/grandyang/p/8887985.html&#34;&gt;这篇文章&lt;/a&gt;可以作为参考。&lt;/p&gt;

&lt;p&gt;需要注意的一个细节是stack中存的不是数字（温度），而是数字的位置，这样我们在能用位置拿到数字的同时还能知道结果应该存在result数组的哪个位置。&lt;/p&gt;

&lt;h4 id=&#34;code&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dailyTemperatures&lt;/span&gt;(temps):
    stack &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; len(temps)

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i, temp &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; enumerate(temps):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; stack &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; temp &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; temps[stack[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]]:
            result[stack[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; stack[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]
            stack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pop()
        stack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(i)

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;question-2&#34;&gt;Question 2&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/trapping-rain-water/&#34;&gt;Leetcode 42: Trapping Rain Water&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.&lt;/p&gt;

&lt;h3 id=&#34;example-1&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;&lt;img class=&#34;special-img-class&#34; style=&#34;width:50%&#34; src=&#34;https://ericliu03.github.io/img/monotone_stack_img2.png&#34; /&gt;
The above elevation map is represented by array &lt;code&gt;T=[0,1,0,2,1,0,1,3,2,1,2,1]&lt;/code&gt;. In this case, 6 units of rain water (blue section) are being trapped.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: [0,1,0,2,1,0,1,3,2,1,2,1]
Output: 6
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution-1&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;method-1-1&#34;&gt;Method 1&lt;/h3&gt;

&lt;h4 id=&#34;analysis-1&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;本题有很多解法，这里还是讲monotone stack。与上题相同，stack应当还是monotonically decreasing的，因为只有遇到比栈顶高的bar，才有可能存住水。不同的地方在于当我们遇到比栈顶大的数的时候的所做的事情。&lt;/p&gt;

&lt;p&gt;本题中，遇到比栈顶大的数之后我们就可以存水了。但是存水量的计算有点不intuitive，我们需要左右两遍的bar，和&lt;strong&gt;中间的坑&lt;/strong&gt;。我们稍微改变一下题目的例子，把&lt;code&gt;T[6]&lt;/code&gt;变成0。假设现在我们走到了&lt;code&gt;i = 3&lt;/code&gt;，前面的数都比2小所以都pop出去了，stack是&lt;code&gt;[2]&lt;/code&gt;。继续往后走直到&lt;code&gt;index = 6&lt;/code&gt;stack变成&lt;code&gt;[2,1,0,0]&lt;/code&gt;，下一步&lt;code&gt;T[7]=3&lt;/code&gt;，比stack的顶要大，可以作为右边的bar。 栈顶元素（0）就要变做坑，然后我们就继续pop，直到遇到了比坑高的（1）作为左边的bar。水量就是坑的长度乘以坑的深度（&lt;code&gt;min（左bar，右bar）- 坑底部的高度）&lt;/code&gt;。因为&lt;code&gt;T[3]=2&lt;/code&gt;还是比&lt;code&gt;T[7]&lt;/code&gt;小，我们再进行一次同样的水量计算。注意刚才左边的bar是没有取出来的，目的就是在这轮可以用作坑。或者从另一个角度理解，我们刚刚才左bar到右bar之间取出来水之后填上了土，所以坑的高度就变成了左bar。&lt;/p&gt;

&lt;p&gt;不容易理解的地方就是，两次计算完毕你会发现水量是根据左bar或者右bar的高度横向计算的，在这个例子里从&lt;code&gt;T[4] -&amp;gt; T[7]&lt;/code&gt; 高度&lt;code&gt;1-0&lt;/code&gt;计算一次，然后&lt;code&gt;T[3] -&amp;gt; T[7]&lt;/code&gt;高度&lt;code&gt;2-1&lt;/code&gt;计算一次。双指针的解法中水量是竖向计算的。&lt;/p&gt;

&lt;h4 id=&#34;code-1&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;trap&lt;/span&gt;(heights):
    stack &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i, h &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; enumerate(heights):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; stack &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; h &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; heights[stack[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]]:
            pit_h &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; heights[stack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pop()]
            &lt;span style=&#34;color:#75715e&#34;&gt;# we have to have a left bar to trap water&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; stack:
                result &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; (min(h, heights[stack[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]]) &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; pit_h) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; stack[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
        stack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(i)

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;question-3&#34;&gt;Question 3&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/largest-rectangle-in-histogram/&#34;&gt;Leetcode 84: Largest Rectangle in Histogram&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given n non-negative integers representing the histogram&amp;rsquo;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.&lt;/p&gt;

&lt;h3 id=&#34;example-2&#34;&gt;Example&lt;/h3&gt;

&lt;p&gt;&lt;img class=&#34;special-img-class&#34; style=&#34;width:30%&#34; src=&#34;https://ericliu03.github.io/img/monotone_stack_img3.png&#34; /&gt;
&lt;em&gt;Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].  The largest rectangle is shown in the shaded area, which has area = 10 unit.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;solution-2&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;method-1-2&#34;&gt;Method 1&lt;/h3&gt;

&lt;h4 id=&#34;analysis-2&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;我们依然使用monotone stack的方式来解决这道题。与存水同样的思路，只有新数字小于栈顶时我们进行计算。计算的方式类似但是略有不同。以上图举例，当我们走到数字&lt;code&gt;2&lt;/code&gt;时，stack中是&lt;code&gt;[1,5,6]&lt;/code&gt;。&lt;code&gt;2&amp;lt;6&lt;/code&gt;所以开始计算，计算的方式是&lt;code&gt;木板的块数 * 栈顶木板的高度&lt;/code&gt;。计算完成后比较结果与目前的已知最大面积，然后pop 6出来，发现&lt;code&gt;2&amp;lt;5&lt;/code&gt;所以再次计算，直到栈顶数字小于当前数字。之后我们把2push进入之后继续往后走直到结束。存的最大面积就是结果。&lt;/p&gt;

&lt;p&gt;这里模板的块数的计算有点tricky。如上图所示，当我们走到最后的时候，stack中是&lt;code&gt;[1,2,3]&lt;/code&gt;。以高度3为顶的计算就是&lt;code&gt;(6-5) * 3&lt;/code&gt;，但是当pop出3之后，以2为顶计算时，左边界index不是4，而是2。因为我们知道2左边被pop出去的板子都比2高，所以我们计算面积时应该把那些板子都算进去。那么怎么找pop出了多少呢？如果stack中还有数字的话，那么2左边的那个就是第一个比2小的，如果没有就说明2就是最小的我们应该把0作为左边界。&lt;/p&gt;

&lt;p&gt;有几点可能对理解有所帮助：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;木板面积可以这样计算的原因是我们进行了类似于&lt;em&gt;填坑&lt;/em&gt; 的削顶，也就是说当把6拿出来之后，我们看到下一个数字是5，那么我们就知道 1.目前最矮的是5，2. pop出去的都比5高，所以形成的正方形肯定最高就是5，横向长度就是目前为止到这个高度为5的板子的距离。&lt;/li&gt;
&lt;li&gt;计算板子面积不需要像存水一样有左右bar和坑，我们需要左右边界。

&lt;ol&gt;
&lt;li&gt;在给定的输入最后填上一个0作为空的右边界，以保证最后一块板子也参与了计算。&lt;/li&gt;
&lt;li&gt;计算面积时如果stack为空那么左边界就是0。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;每块板子的所有组成的方块其实都被显式或者隐式的计算过。比如上面计算6 * 1 的时候就是6作为方块的唯一一块板子，下一步5 * 2的时候6其实也包含在了板子中。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;推荐看一下reference 4，博主配上了很多图片便于理解。但是博客给的图片关于计算面积是有错误的，他的左边界是选的当前栈顶的位置。&lt;/p&gt;

&lt;h4 id=&#34;code-2&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;largestRectangleArea&lt;/span&gt;(heights):
    heights&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
    stack &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; []
    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i, h &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; enumerate(heights):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; stack &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; heights[stack[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; h:
            bar_i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pop()
            l_i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stack[&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; stack &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
            result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(result, (i &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; l_i) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; heights[bar_i])
        stack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(i)

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;其他可以使用Monotone stack解的题目

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/next-greater-element-i/&#34;&gt;Leetcode 496&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://leetcode.com/problems/next-greater-node-in-linked-list/&#34;&gt;Leetcode 1019&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/grandyang/p/8887985.html&#34;&gt;LeetCode Monotone Stack Summary 单调栈小结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/grandyang/p/4402392.html&#34;&gt;解法：Trapping Rain Water 收集雨水&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/lichen782/p/leetcode_Largest_Rectangle_in_Histogram.html&#34;&gt;LeetCode 笔记系列 17 Largest Rectangle in Histogram&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://fisherlei.blogspot.com/2012/12/leetcode-largest-rectangle-in-histogram.html&#34;&gt;水中的鱼：Largest Rectangle in Histogram 解题报告&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Maximum Difference Between Node and Ancestor</title>
      <link>https://ericliu03.github.io/posts/2019/04/maximum_diff_between_node_and_ancestor/</link>
      <pubDate>Tue, 16 Apr 2019 21:16:39 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/maximum_diff_between_node_and_ancestor/</guid>
      <description>

&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/maximum-difference-between-node-and-ancestor/&#34;&gt;Leetcode 1026&lt;/a&gt;:
Given the root of a binary tree, find the maximum value &lt;code&gt;V&lt;/code&gt; for which there exists &lt;strong&gt;different&lt;/strong&gt; nodes A and B where &lt;code&gt;V = |A.val - B.val|&lt;/code&gt; and A is an ancestor of B.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(A node A is an ancestor of B if either: any child of A is equal to B, or any child of A is an ancestor of B.)&lt;/em&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TreeNode&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __init__(self, x):
        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x
        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; None
        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; None&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;&lt;img class=&#34;special-img-class&#34; style=&#34;width:50%&#34; src=&#34;https://ericliu03.github.io/img/maximum_diff_between_node_and_ancestor_img1.jpg&#34; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: [8,3,10,1,6,null,14,null,null,4,7,13]
Output: 7
Explanation: 
We have various ancestor-node differences, some of which are given below :
|8 - 3| = 5
|3 - 7| = 4
|8 - 1| = 7
|10 - 13| = 3
Among all possible differences, the maximum value of 7 is obtained by |8 - 1| = 7.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;solution&#34;&gt;Solution&lt;/h2&gt;

&lt;h3 id=&#34;method-1&#34;&gt;Method 1&lt;/h3&gt;

&lt;h4 id=&#34;analysis&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;Bottom up solution: we collect results from a node&amp;rsquo;s left and right child and calculate result of this node&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;each node will need three things from both left and right child

&lt;ol&gt;
&lt;li&gt;min and max num in subtree (for calculating this node&amp;rsquo;s difference with it&amp;rsquo;s max and min decendents)&lt;/li&gt;
&lt;li&gt;max diff in subtree&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;combine the results given from children&lt;/li&gt;
&lt;li&gt;calculate result with current node&amp;rsquo;s value and return&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;code&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maxAncestorDiff&lt;/span&gt;(root):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; root &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; None:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; helper(root)[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]


&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;helper&lt;/span&gt;(node):
    min_num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max_num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val
    diff &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left:
        temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; helper(node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left)
        min_num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(min_num, temp[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;])
        max_num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(max_num, temp[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
        diff &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(diff, temp[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;])
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right:
        temp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; helper(node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right)
        min_num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(min_num, temp[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;])
        max_num &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(max_num, temp[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
        diff &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(diff, temp[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;])
    
    diff &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(diff, max(abs(node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; min_num), abs(node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; max_num)))
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; min_num, max_num, diff&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;method-2&#34;&gt;Method 2&lt;/h3&gt;

&lt;h4 id=&#34;analysis-1&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;Top down solution: the question is about nodes and their ancestors so we don&amp;rsquo;t need to gather and combine results from both children to calculate result&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;function is given min and max of numbers in the path from root to current node&lt;/li&gt;
&lt;li&gt;update min or max with current node&amp;rsquo;s value and pass it to it&amp;rsquo;s children&lt;/li&gt;
&lt;li&gt;when we reached the leaf, we calculate the result by using this min and max nums&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;maxAncestorDiff&lt;/span&gt;(root):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; helper(root, root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val, root&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val)


&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;helper&lt;/span&gt;(node, lo, hi):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; node &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; None:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; hi &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; lo

    lo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(lo, node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val)
    hi &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(hi, node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val)

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; max(helper(node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left, lo, hi), helper(node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right, lo, hi))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Longest Increasing Subsequence (Chinese)</title>
      <link>https://ericliu03.github.io/posts/2019/04/longest_increasing_subsequence/</link>
      <pubDate>Mon, 15 Apr 2019 20:03:06 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/longest_increasing_subsequence/</guid>
      <description>

&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;

&lt;p&gt;This question is from &lt;a href=&#34;https://leetcode.com/problems/longest-increasing-subsequence/&#34;&gt;Leetcode 300&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Given an unsorted array of integers, find the length of longest increasing subsequence.&lt;/p&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Input: [10,9,2,5,3,7,101,18]
Output: 4 
Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. 
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;note&#34;&gt;Note&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;There may be more than one LIS combination, it is only necessary for you to return the length.&lt;/li&gt;
&lt;li&gt;Your algorithm should run in \( O(N^2) \) complexity.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;method-1&#34;&gt;Method 1&lt;/h3&gt;

&lt;h4 id=&#34;analysis&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;可以使用Brute force的方法来解决这个问题。
具体来说我们需要试一下所有可能的组合：对于每一个数&lt;strong&gt;x&lt;/strong&gt;，他本身加上他后面的任意一个比他大的数&lt;strong&gt;y&lt;/strong&gt;都可以组成一个increasing subsequence。如果我们已经知道了以&lt;strong&gt;y&lt;/strong&gt;开头（对，就是recursion的思想），最长能组成的subsequence的长度，我们就知道了以&lt;strong&gt;x&lt;/strong&gt;和&lt;strong&gt;y&lt;/strong&gt;开头的最长的长度。但是选y只是以x开头的increasing subsequence的可能性之一。或许有一个数字&lt;strong&gt;z&lt;/strong&gt;也符合条件（比x大，在x的后面），如果以z开头的increasing subsequence 的最长长度比以y开头的长，那么对于x来说，更好地选项就是接上z，以xz开头。 所以，为了知道最长的到底是那个，需要把后面所有符合条件的数都拿来试一下，然后选那个最长的。
时间复杂度是\( O(N!) \)：对于第一个数字，需要进行 (n-1) * (n-2) * &amp;hellip; * 1，第二个是 (n-2) * (n-3) * &amp;hellip; * 1, 第n个是1。&lt;/p&gt;

&lt;p&gt;Leetcode也提供了&lt;a href=&#34;https://leetcode.com/problems/longest-increasing-subsequence/solution/&#34;&gt;另一种BF&lt;/a&gt;的方法。那个方法对于recursion function的定义不同，时间复杂度也只有O(2^n)。原因是相比于上面的方法，在每个点只进行了两次recursion call，而不是n次。&lt;/p&gt;

&lt;p&gt;你应该能发现我们recursion function的定义，是求以当前数字作为开头，最长的increasing subsequence的长度。既然是最长，那么也就是说只要给定start位置和list，这个结果就只有一个。然而在上面的算法中，对于同一个点我们计算了很多次（对于每个数，我们计算的次数等于他前面比他小的数字的数量）。所以我们可以把计算的结果存起来，只计算一次。&lt;/p&gt;

&lt;p&gt;那么时间复杂度就变成了\( O(N^2) \)，因为对于每个点，我们依然要看一下剩下符合要求的点的最长长度然后计算出自己的长度。&lt;/p&gt;

&lt;h4 id=&#34;code&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Solution&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lengthOfLIS&lt;/span&gt;(self, nums: List[int]) &lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt; int:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; nums:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;memo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; max([self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;helper(i, nums) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(nums))])
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;helper&lt;/span&gt;(self, start, nums):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; start &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;memo:
            result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(start&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, len(nums)):
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; nums[start]:
                    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(result, self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;helper(i, nums))
            self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;memo[start] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; result&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
            
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;memo[start]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;method-2&#34;&gt;Method 2&lt;/h3&gt;

&lt;h4 id=&#34;analysis-1&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;一般来说recursion的问题都可以优化成DP的解法，此题就是如此。我们上面说&lt;strong&gt;这里recursion function的定义，是求以当前数字作为开头，最长的increasing subsequence的长度&lt;/strong&gt;。在recursion中， 我们是从前往后call recursion function，但是实际计算是从后往前。换句话说，我们每一层recursion都需要后面一层的结果，所以第一个真正计算出的结果是最后一层，也就是&lt;strong&gt;以最后一个数字作为开头的最长的长度&lt;/strong&gt;（那便是1啦）。如果按照真正计算的顺序（即从右向左）计算，然后记录下来计算结果后给后面的计算使用，就是DP的解法。&lt;/p&gt;

&lt;p&gt;在LC中提供的DP解法是反过来，从左向右计算，随之而变化的是存的每个点的数据的定义，也变为&lt;strong&gt;以当前数字为结尾，最长increasing subsequence的长度&lt;/strong&gt;。所以对于每一个数字，我们都需要看一下符合条件的数，也即在他前面且比他小的数（可以看到是正好反过来的），找出最长的作为当前数字的结果。从前往后是自然而然的顺序，但是如果是用BF的方法推导过来，却是需要转换一下才可。&lt;/p&gt;

&lt;h4 id=&#34;code-1&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;lengthOfLIS&lt;/span&gt;(nums):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; nums:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;

    dp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; len(nums)

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; hi &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(nums)):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; lo &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(hi):
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[lo] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; nums[hi]:
                dp[hi] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(dp[hi], dp[lo] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; max(dp)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;follow-up-1&#34;&gt;Follow up 1&lt;/h3&gt;

&lt;h4 id=&#34;question-1&#34;&gt;Question&lt;/h4&gt;

&lt;p&gt;From &lt;a href=&#34;https://leetcode.com/problems/number-of-longest-increasing-subsequence/&#34;&gt;Leetcode 673&lt;/a&gt;:
Given an unsorted array of integers, find the number of longest increasing subsequence.&lt;/p&gt;

&lt;h4 id=&#34;examples-1&#34;&gt;Examples&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Example 1:
Input: [1,3,5,4,7]
Output: 2
Explanation: The two longest increasing subsequence are [1, 3, 4, 7] and [1, 3, 5, 7].
Example 2:
Input: [2,2,2,2,2]
Output: 5
Explanation: The length of longest continuous increasing subsequence is 1, and there are 5 subsequences&#39; length is 1, so output 5.
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;analysis-2&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;这个题目和上面题目唯一不同的地方就是之前的是求最长的长度，这个是求拥有最长长度的subsequence有多少个。如果你walk through了之前的DP解法就会发现，同样长度的结果的确可能遇到过多个。比如我们在例子1中最后一个数字7的时候，在index为2和3（就是数字5和4）时，DP[2]和DP[3]都应该等于3，因为135和134长度都为3。那么在上面DP解法第十行的&lt;code&gt;dp[j] = max(dp[j], dp[i] + 1)&lt;/code&gt;就是说明dp[j]等于dp[i]+1。&lt;/p&gt;

&lt;p&gt;在本题目中我们需要记录下来遇到这种情况的数量，也就是在每一位不仅记录以当前为结尾数字的subsequence的最大长度，也记录有此长度的不同subsequence有多少个。这样一来，最后的时候我们就可以使用整个dp数组中最长的那个长度，作为整个数组的最长度，再用这个长度去找总共这个长度的subsequence有多少个。&lt;/p&gt;

&lt;h4 id=&#34;code-2&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;numberOfLIS&lt;/span&gt;(nums):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; nums:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
        
        dp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; len(nums)
        counts &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; len(nums)
        
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; hi &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(nums)):
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; lo &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(hi):
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; nums[lo] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; nums[hi]:
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; dp[hi] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; dp[lo] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:
                        dp[hi] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; dp[lo] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
                        counts[hi] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; counts[lo]
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;elif&lt;/span&gt; dp[hi] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; dp[lo] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:
                        counts[hi] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; counts[lo]

        max_len  &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(dp)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; sum([counts[i] &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(nums)) &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; dp[i] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; max_len])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;follow-up-2&#34;&gt;Follow up 2&lt;/h3&gt;

&lt;h4 id=&#34;question-2&#34;&gt;Question&lt;/h4&gt;

&lt;p&gt;From &lt;a href=&#34;https://leetcode.com/problems/longest-arithmetic-sequence/&#34;&gt;Leetcode 1027&lt;/a&gt;:
Given an array A of integers, return the length of the longest arithmetic subsequence in A.&lt;/p&gt;

&lt;p&gt;Recall that a subsequence of A is a list &lt;code&gt;A[i_1], A[i_2], ..., A[i_k]&lt;/code&gt; with &lt;code&gt;0 &amp;lt;= i_1 &amp;lt; i_2 &amp;lt; ... &amp;lt; i_k &amp;lt;= A.length - 1&lt;/code&gt;, and that a sequence B is arithmetic if &lt;code&gt;B[i+1] - B[i]&lt;/code&gt; are all the same value (for &lt;code&gt;0 &amp;lt;= i &amp;lt; B.length - 1&lt;/code&gt;).&lt;/p&gt;

&lt;h4 id=&#34;examples-2&#34;&gt;Examples&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;Example 1
Input: [9,4,7,2,10]
Output: 3
Explanation: 
The longest arithmetic subsequence is [4,7,10].

Example 2:
Input: [20,1,15,3,10,5,8]
Output: 4
Explanation: 
The longest arithmetic subsequence is [20,15,10,5].
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;analysis-3&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;看过了上面这么多题目和解法，看到这应该有感觉到需要用类似的方法做。和原题唯一的区别就是条件：原题的条件是右边的数大于左边的数，此题的条件是右边的数减左边的数等于一个差值。这个差值是由subsequence的头两个数决定的。同样的，我们可以用一个数组&lt;code&gt;dp[]&lt;/code&gt;来存以当前数字为结尾的subsequence的最长长度，但不同的是对于不一样的差值可以会有相同或者不同的最长长度，比如例子1中，以7结尾，差值为-2时，长度为2，差值为3时长度也为2（未出现的差值我们可以不记录）。在比如当到了10的时候，差值为3是就是3（接上了7），其他的（比如1，6等等）最长的只有2了。所以我们可以想到，对于每一个数字的每一种可能的差值，我们都需要记录下来其最长subsequence的长度，以备后面的数字使用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;longestArithSeqLength&lt;/span&gt;(nums):
    dp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [collections&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;defaultdict(int) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(nums))]
    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; hi &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(len(nums)):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; lo &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(hi):
            diff &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; nums[hi] &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; nums[lo]
            dp[hi][diff] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(dp[hi][diff], dp[lo][diff] &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
            result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(result, dp[hi][diff])        
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;	&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;后记&#34;&gt;后记&lt;/h3&gt;

&lt;p&gt;这篇文章其实是收到了最后一个题目（follow up2）的启发，是在做LC contest的时候遇到的。回忆起来，当时感觉题目有点熟悉，但没想到和原题的关联。当时只想到了BF算法，自然也超时了。理论上用BF加memo的方法也可以做，但是因为加入了diff的缘故导致稍微有点复杂，就被绕晕了。想要思路清晰的快速解题，还是要熟练啊&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Inorder Predecessor</title>
      <link>https://ericliu03.github.io/posts/2019/04/inorder_predecessor/</link>
      <pubDate>Sat, 13 Apr 2019 21:55:51 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/inorder_predecessor/</guid>
      <description>

&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;

&lt;p&gt;Given a node in a binary tree, return the inorder predecessor of that node. If it doesn&amp;rsquo;t exist, return null. Both input and output should be node objects.&lt;/p&gt;

&lt;p&gt;Node is given as an object with pointers to it&amp;rsquo;s left child, right child and parent.&lt;/p&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;h4 id=&#34;example-1&#34;&gt;Example 1&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;     A
    / \
   B   C
  / \
 D   E
    /
   F

In order traversal: DBFEAC
If give A, then return should be E. 
If give C, should return A. 
If give F, should return B. 
If give D, return null.
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;algorithm&#34;&gt;Algorithm&lt;/h2&gt;

&lt;h4 id=&#34;method-1&#34;&gt;Method 1&lt;/h4&gt;

&lt;h4 id=&#34;analysis&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;First, there are &lt;a href=&#34;https://en.wikipedia.org/wiki/Tree_traversal&#34;&gt;several ways&lt;/a&gt; to traverse a tree, and in the problem it&amp;rsquo;s using in-order traversal. Basically, in-order traversal is to &amp;ldquo;display root node at &lt;em&gt;in&lt;/em&gt; position&amp;rdquo;, i.e. 1. display left subtree, display root and display right sub tree. Something like this: &lt;strong&gt;[left-subtree-inorder-list] + root + [right-subtree-inorder-list]&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For this question, the easiest way is to find the root of the tree using the pointer to parent in each node, and do a in-order traversal to generate a list. The time and space complexity would be O(n). Can we do better?&lt;/p&gt;

&lt;h4 id=&#34;method-2&#34;&gt;Method 2&lt;/h4&gt;

&lt;h4 id=&#34;analysis-1&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;We have the pointer to parents, so we should be able to go anywhere in the graph. The question is where to go?&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s say &lt;strong&gt;X&lt;/strong&gt; is the node given:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Case 1: if X has left child as &lt;strong&gt;A&lt;/strong&gt; in example. Then we are sure it&amp;rsquo;s predecessor is in it&amp;rsquo;s left subtree, and it should be the last node of the subtree&amp;rsquo;s inorder list. The last node in the in-order traversal of a tree will be the right most node in the tree. As a result, &lt;strong&gt;we go left, and go right until no right child.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Case 2: if X doesn&amp;rsquo;t have left child, it means in the subtree where X is the root, X is the first node in it&amp;rsquo;s inorder list. We have to find it&amp;rsquo;s predecessor outside of this subtree. So thinking about X&amp;rsquo;s parent &lt;strong&gt;Y&lt;/strong&gt;,

&lt;ul&gt;
&lt;li&gt;Case 2.1: if X is Y&amp;rsquo;s right child as &lt;strong&gt;C&lt;/strong&gt; in example, Y will the X&amp;rsquo;s predecessor: X is the first node (in-order) in Y&amp;rsquo;s right subtree.&lt;/li&gt;
&lt;li&gt;Case 2.2: if X is Y&amp;rsquo;s left child as &lt;strong&gt;F&lt;/strong&gt; in example, then Y will not be the predecessor: Y&amp;rsquo;s right subtree plus Y will be after X in the in-order list. &lt;strong&gt;X will still be the first node in the inorder list that generated from the subtree with Y as the root&lt;/strong&gt;. Then if we go one level up to Y&amp;rsquo;s parent &lt;strong&gt;Z&lt;/strong&gt;, it will be a similar situation: if Y is Z&amp;rsquo;s left child, Z plus all the nodes in Z&amp;rsquo;s right subtree will be after Y, and thus X, in the inorder list. We have to go up, until we meet a case like case 2.1, where &lt;strong&gt;Y*&lt;/strong&gt; is &lt;strong&gt;Z*&amp;rsquo;s&lt;/strong&gt; right child. In this case, in subtree with Z* as root, Z* will be in the middle, and X is the first node in the inorder list of Z*&amp;rsquo;s right subtree, which means X&amp;rsquo;s predecessor is Z*.&lt;/li&gt;
&lt;li&gt;Case 2.3: As &lt;strong&gt;D&lt;/strong&gt; in example, If we can&amp;rsquo;t find a node like Z* and we don&amp;rsquo;t have a &amp;ldquo;parent&amp;rdquo; to go up any more, then it means X is the first node in the inorder list and we should return null.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;code&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;inorder_predecessor&lt;/span&gt;(node):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; node &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; None:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; None

    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; None:
        curr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; curr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right:
            curr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; curr&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; curr
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;parent:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;parent&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; node:
                &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;parent
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
                node &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;parent
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; None

&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt;:
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __init__(self, val, parent):
        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; val
        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;parent &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; parent
        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; None
        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; None

    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __str__(self):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    
    <item>
      <title>Minimum Point to Traverse Graph</title>
      <link>https://ericliu03.github.io/posts/2019/04/minimum_point_to_traverse_graph/</link>
      <pubDate>Wed, 10 Apr 2019 15:38:14 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/minimum_point_to_traverse_graph/</guid>
      <description>

&lt;h2 id=&#34;question&#34;&gt;Question&lt;/h2&gt;

&lt;p&gt;There is a directed graph and you can traverse the nodes in this graph by following the directed edges. You can start from any node in this graph and you can pick nodes as start points as many as you needed. What is the minimum number of nodes as start points you need to traverse all the nodes?&lt;/p&gt;

&lt;p&gt;You will be given a number n as number of vertices in the graph, and a list contains all the edges in the graph.&lt;/p&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;input: 4, [[0,1], [1,2],[2,3]]
output: 1. we just need to pick 1 as start point and will be able to traverse the whole graph
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;input: 4, [[2,1], [3,1],[0,1]]
output: 3. we have to start from 2,3 and 4 to reach all the nodes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 3:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;input: 6, [[0,1], [1,2], [2,0], [2,3], [3,4], [4,5], [5,3]]
output: 1, we could start from 3, then we could go through 0-&amp;gt;1-&amp;gt;2-&amp;gt;0, and 2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 4:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;input: 5, [[0, 1], [1, 2], [2, 3], [3, 0], [4, 0]]
output: 1, we start from 4
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;algorithm&#34;&gt;Algorithm&lt;/h2&gt;

&lt;h3 id=&#34;method-1&#34;&gt;Method 1&lt;/h3&gt;

&lt;h4 id=&#34;analysis&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;Starting from the problem description, the most straightforward is to use a recursive method. We could have a loop of all the nodes in the graph. We treat each node as a start point of a DFS and see if we can traverse the whole graph. If yes, then we return 1 since we used 1 node as start point. If not, then we go 1 level deeper in the recursive function, which is another loop of the nodes, but here instead of all the nodes, we only use the nodes we can&amp;rsquo;t reach in the previous DFS. We should be able to get one result for each node that picked as starting point. We choose the smallest number among those and plus one to return as the nodes needed to cover all the nodes.&lt;/p&gt;

&lt;h4 id=&#34;code&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; collections

&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;minimum_nodes&lt;/span&gt;(n, edges):
    outdegrees &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; collections&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;defaultdict(set)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; u, v &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; edges:
        outdegrees[u]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add(v)

    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;)
    unvisited &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set([i &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n)])
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n):
        result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(result, dfs(i, outdegrees, unvisited))
        &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(result, i)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result


&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dfs&lt;/span&gt;(start, outdegrees, unvisited):
    unvisited_set &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; unvisited&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;copy()
    queue &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [start]
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; queue:
        curr_node &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; queue&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pop(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; curr_node &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; unvisited_set:
            unvisited_set&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;remove(curr_node)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; neighbor &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; outdegrees[curr_node]:
                queue&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(neighbor)

    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(unvisited_set) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
        result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; unvisited &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; unvisited_set:
            result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(result, dfs(unvisited, outdegrees, unvisited_set))
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;method-2&#34;&gt;Method 2&lt;/h3&gt;

&lt;h4 id=&#34;analysis-1&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;Thinking about the recursive function, we should notice that we did a lot duplicated works there. (Actually, if the problem is not asking for all possible ways/permutations, then there should always be duplicated works.) In this way, this could be optimized using idea of &lt;a href=&#34;https://en.wikipedia.org/wiki/Dynamic_programming&#34;&gt;Dynamic Programing&lt;/a&gt;. There are two general ways of doing DP, 1. use a map to remember what&amp;rsquo;s the result from a start point (in this problem the start point is the node we choose as start), and go through the path using recursive function 2. use a n-Dimension array to store the result and derive results from previous results.
Here we could use the first way to remember the result of &lt;strong&gt;the nodes we could reach when starting from node u&lt;/strong&gt;. Then each time we start the DFS, we first check if we have already examen that node as start point and if we do return the result.&lt;/p&gt;

&lt;h4 id=&#34;code-1&#34;&gt;Code&lt;/h4&gt;

&lt;p&gt;This is similar to method 1, just we remember the results we already have. But the code looks messier =|&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;minimum_nodes&lt;/span&gt;(n, edges):
    memo &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {}
    outdegrees &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; collections&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;defaultdict(set)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; u, v &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; edges:
        outdegrees[u]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add(v)

    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;)
    unvisited &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set([i &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n)])
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n):
        result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(result, dfs(i, memo, outdegrees, unvisited))
        &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(result, i)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result


&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dfs&lt;/span&gt;(start, memo, outdegrees, unvisited):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; start &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; memo:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; memo[start]
    unvisited_set &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; unvisited&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;copy()
    queue &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [start]
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; queue:
        curr_node &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; queue&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pop(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; curr_node &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; unvisited_set:
            unvisited_set&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;remove(curr_node)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; neighbor &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; outdegrees[curr_node]:
                queue&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(neighbor)

    result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; float(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;inf&amp;#39;&lt;/span&gt;)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(unvisited_set) &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;:
        result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; unvisited &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; unvisited_set:
            result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(result, dfs(unvisited, memo, outdegrees, unvisited_set))
        result &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;

    memo[start] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; result
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;method-3&#34;&gt;Method 3&lt;/h3&gt;

&lt;h4 id=&#34;analysis-2&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;Instead of remembering everything in a map during the recursion, we could remember something else. There are two things we need, 1. the vertices we already visited in &lt;code&gt;visited&lt;/code&gt;, 2. the start points we choose in &lt;code&gt;start_points&lt;/code&gt;. Still, we loop through every vertex, say &lt;strong&gt;u&lt;/strong&gt; in the graph that not in &lt;code&gt;visited&lt;/code&gt;, do a search (either DFS or BFS) to get all the vertices that could be reached started with &lt;strong&gt;u&lt;/strong&gt;. The following is the &lt;strong&gt;key&lt;/strong&gt; to this algorithm: 1. we add those reached vertices to &lt;code&gt;visited&lt;/code&gt;, so we won&amp;rsquo;t do duplicated work, 2. if in the reached vertices, there&amp;rsquo;s any &lt;strong&gt;start points we chose, we remove those start points,&lt;/strong&gt; from &lt;code&gt;start_points&lt;/code&gt;. 3. add &lt;strong&gt;u&lt;/strong&gt; to &lt;code&gt;start_points&lt;/code&gt;. This is because we could reach the &lt;strong&gt;removed start points&lt;/strong&gt; from &lt;strong&gt;u&lt;/strong&gt;, and thus the vertices that the old start vertex can reach. So there&amp;rsquo;s no need to keep the old start point anymore.&lt;/p&gt;

&lt;h4 id=&#34;code-2&#34;&gt;Code&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;minimum_nodes3&lt;/span&gt;(n, edges):
    outdegrees &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; collections&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;defaultdict(set)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; u, v &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; edges:
        outdegrees[u]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add(v)

    visited &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set()
    starts &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set()
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; vertex &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(n):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; vertex &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; visited:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;

        reached &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; get_reached(vertex, outdegrees)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; list(starts):
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; s &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; reached:
                starts&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;remove(s)
        visited&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;update(reached)
        starts&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add(vertex)

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; len(starts)


&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;get_reached&lt;/span&gt;(start, outdegrees):
    visited &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set()
    queue &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [start]
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; queue:
        curr_node &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; queue&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pop(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; curr_node &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; visited:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;

        visited&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add(curr_node)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; neighbor &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; outdegrees[curr_node]:
            queue&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(neighbor)

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; visited&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;method-4&#34;&gt;Method 4&lt;/h3&gt;

&lt;h4 id=&#34;analysis-3&#34;&gt;Analysis&lt;/h4&gt;

&lt;p&gt;In the graph theory, there&amp;rsquo;s a concept called &lt;a href=&#34;https://en.wikipedia.org/wiki/Strongly_connected_component&#34;&gt;&lt;strong&gt;Strongly Connected Component(SCC)&lt;/strong&gt;&lt;/a&gt;. If you don&amp;rsquo;t know you should read about it. In short, all nodes in a SCC has a path to go to any other nodes in the same SCC. So what we need from it for this problem is that we want to treat the nodes in same SCC as one single node in a graph. After that the graph will be a DAG, and we just need to count how many nodes don&amp;rsquo;t have incoming edges (i.e. 0 in-degree). Those nodes will be the start points.&lt;/p&gt;

&lt;p&gt;In reference 1, code for this solution is given, which used Tarjan Algorithm. I attached some great explanation in reference for this algorithm. I will write my understanding of Tarjan in the following. It uses a stack to represent the vertices that are currently visiting, and it uses &lt;code&gt;dfn[u]&lt;/code&gt; to store IDs of vertices and &lt;code&gt;low[u]&lt;/code&gt; to represent the vertex with lowest ID it can reach. As an example, is 6 can reach 4 (so &lt;code&gt;low[6] = 4&lt;/code&gt;), and 4 can reach 1 (&lt;code&gt;low[4] = 1&lt;/code&gt;). From this we know 6 can reach 1 but during the algorithm this will not be recorded directly in &lt;code&gt;low&lt;/code&gt;. If &lt;code&gt;low[x]&lt;/code&gt; equals to x itself, then it means it can&amp;rsquo;t go back any further, and it will be recognized as &lt;em&gt;root&lt;/em&gt; of this SCC. Thus all the vertices in the stack and pushed later then this &lt;em&gt;root&lt;/em&gt; (i.e. we are visiting) will belongs to this SCC. This is because from this &lt;em&gt;root&lt;/em&gt; we reached all those vertices, and somehow those vertices can comes back to this &lt;em&gt;root&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;In my opinion this is way more complicated in an interview, so I will just skip it here.&lt;/p&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://www.1point3acres.com/bbs/forum.php?mod=viewthread&amp;amp;tid=319799&#34;&gt;[树/链表/图] 求教Airbnb的graph traversal问题 &lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.miskcoo.com/2016/07/tarjan-algorithm-strongly-connected-components&#34;&gt;Tarjan算法寻找有向图的强连通分量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/hurmishine/article/details/75248876&#34;&gt;全网最!详!细!Tarjan算法讲解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.cnblogs.com/nullzx/p/6437926.html&#34;&gt;Kosaraju算法解析: 求解图的强连通分量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/dm_vincent/article/details/8554244&#34;&gt;求解强连通分量算法之&amp;mdash;Kosaraju算法&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Video Stitching</title>
      <link>https://ericliu03.github.io/posts/2019/04/video_stitching/</link>
      <pubDate>Mon, 08 Apr 2019 20:01:29 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/video_stitching/</guid>
      <description>

&lt;p&gt;This is a question from &lt;a href=&#34;https://leetcode.com/problems/video-stitching/&#34;&gt;leetcode.com&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;problem&#34;&gt;Problem&lt;/h2&gt;

&lt;h3 id=&#34;question&#34;&gt;Question&lt;/h3&gt;

&lt;p&gt;You are given a series of video clips from a sporting event that lasted T seconds.  These video clips can be overlapping with each other and have varied lengths.&lt;/p&gt;

&lt;p&gt;Each video clip &lt;code&gt;clips[i]&lt;/code&gt; is an interval: it starts at time &lt;code&gt;clips[i][0]&lt;/code&gt; and ends at time &lt;code&gt;clips[i][1]&lt;/code&gt;.  We can cut these clips into segments freely: for example, a clip &lt;code&gt;[0, 7]&lt;/code&gt; can be cut into segments &lt;code&gt;[0, 1] + [1, 3] + [3, 7]&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Return the minimum number of clips needed so that we can cut the clips into segments that cover the entire sporting event (&lt;code&gt;[0, T]&lt;/code&gt;).  If the task is impossible, return &lt;code&gt;-1&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples&lt;/h3&gt;

&lt;p&gt;Example 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10
Output: 3
Explanation: 
We take the clips [0,2], [8,10], [1,9]; a total of 3 clips.
Then, we can reconstruct the sporting event as follows:
We cut [1,9] into segments [1,2] + [2,8] + [8,9].
Now we have segments [0,2] + [2,8] + [8,10] which cover the sporting event [0, 10].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 2:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: clips = [[0,1],[1,2]], T = 5
Output: -1
Explanation: 
We can&#39;t cover [0,5] with only [0,1] and [0,2].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 3:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9
Output: 3
Explanation: 
We can take clips [0,4], [4,7], and [6,9].
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Example 4:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Input: clips = [[0,4],[2,8]], T = 5
Output: 2
Explanation: 
Notice you can have extra video after the event ends.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 &amp;lt;= clips.length &amp;lt;= 100
0 &amp;lt;= clips[i][0], clips[i][1] &amp;lt;= 100
0 &amp;lt;= T &amp;lt;= 100
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;analysis&#34;&gt;Analysis&lt;/h2&gt;

&lt;p&gt;If we take the core of the problem out, what we need to find is minimum number of ranges that covers [0, T].&lt;/p&gt;

&lt;p&gt;We can start with 0, since 0 is the starting point (left-most position) and we have to cover it. By checking all the sections that starts &amp;lt;= 0, we will know the how long we can reach to the right. For example, in example 3, we have &lt;code&gt;[0,1], [0,2], [0,3], [0,4]&lt;/code&gt;. Then in next step, we could reach any sections that start &amp;lt;= 4. So we will loop through all the sections again and find how long we can reach to the right. If we have &lt;code&gt;[2,9]&lt;/code&gt; and &lt;code&gt;[4,8]&lt;/code&gt;, we will know we can reach 9.&lt;/p&gt;

&lt;p&gt;So in each scan, we will know how far we can reach and once we reach further than T or we can&amp;rsquo;t move, we finished scan and return the result.&lt;/p&gt;

&lt;h2 id=&#34;algorithm&#34;&gt;Algorithm&lt;/h2&gt;

&lt;h3 id=&#34;method-1&#34;&gt;Method 1:&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;video_stitching&lt;/span&gt;(clips, T):
    curr_reached &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; curr_reached &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; T:
        next_reached &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; curr_reached
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; start, end &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; clips:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; start &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; curr_reached &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; end &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; next_reached:
                next_reached &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; end
        count &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; next_reached &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; curr_reached:
            count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
            curr_reached &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next_reached

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; count&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Time complexity: in the worst case, we move one section by one section and need to loop through every section for each section, so \( O(N^2) \)&lt;/p&gt;

&lt;h3 id=&#34;method-2&#34;&gt;Method 2:&lt;/h3&gt;

&lt;p&gt;First we sort this clips based on start time (end time doesn&amp;rsquo;t matter because we will scan all of them). Then during the loop, we will keep record of how far we can go in next round and stop at the section whose start is greater than our current reached point (so that we can concatenate). So in next round, we start at where we stopped and do the same thing.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;video_stitching2&lt;/span&gt;(clips, T):
    clips&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;sort()
    curr_reached &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    count &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
    pos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; pos &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len(clips) &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; curr_reached &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; T:
        next_reached &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; curr_reached
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; pos &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; len(clips) &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; clips[pos][&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; curr_reached:
            next_reached &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; max(next_reached, clips[pos][&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;])
            pos &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        count &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; next_reached &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; curr_reached:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
            curr_reached &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next_reached

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; count &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; curr_reached &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; T &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Time complexity: the scan is \( O(N) \) but sorting is \( O(NlogN) \). So overall the time complexity is \( O(NlogN) \)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Pour Water</title>
      <link>https://ericliu03.github.io/posts/2019/04/pour_water/</link>
      <pubDate>Sun, 07 Apr 2019 14:51:09 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/pour_water/</guid>
      <description>

&lt;p&gt;This is a question from Airbnb onsite interview, also could be found on &lt;a href=&#34;https://leetcode.com/problems/pour-water/&#34;&gt;leetcode&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;question&#34;&gt;Question:&lt;/h2&gt;

&lt;p&gt;We are given an elevation map, &lt;code&gt;heights[i]&lt;/code&gt; representing the height of the terrain at that index. The width at each index is 1. After V units of water fall at index K, how much water is at each index?&lt;/p&gt;

&lt;h3 id=&#34;assumptions&#34;&gt;Assumptions:&lt;/h3&gt;

&lt;p&gt;Now, you should ask some clarify questions and make some assumptions of this questions. There are a lot of good solutions and explanations on &lt;a href=&#34;https://leetcode.com/problems/pour-water/solution/&#34;&gt;leetcode&lt;/a&gt; so I will have a different version of the assumption here.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;If the droplet would eventually fall by moving &lt;strong&gt;right&lt;/strong&gt;, then move &lt;strong&gt;right&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Otherwise, if the droplet would eventually fall by moving &lt;strong&gt;left&lt;/strong&gt;, then move &lt;strong&gt;left&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;Water will move as many as possible.&lt;/li&gt;
&lt;li&gt;However, if the eventually fall position is the first or last position of the map, the water drop will overflow and disappear.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here, &lt;strong&gt;&amp;ldquo;eventually fall&amp;rdquo;&lt;/strong&gt; means that the droplet will eventually be at a lower level if it moves in that direction. Also, &amp;ldquo;level&amp;rdquo; means the height of the terrain plus any water in that column.&lt;/p&gt;

&lt;p&gt;If there&amp;rsquo;s no place for water to eventually fall without overflow, then&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The water drop will overflow either overflow from left or right.&lt;/li&gt;
&lt;li&gt;Otherwise, it will stay at the right most possible position.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples:&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Input: heights = [2,1,1,2,1,2,2], V = 4, K = 3
Output: [2,2,2,3,2,2,2]
Steps:
1. [2,1,1,2,2,2,2]
2. [2,2,1,2,2,2,2]
3. [2,2,2,2,2,2,2]
4. [2,2,2,2,2,2,2] (overflow)

Input: heights = [1,2,3,4], V = 1, K = 2
Output: [1,2,3,4]
Steps:
1. [1,2,3,4] (overflow)

Input: heights = [2,1,1,4], V = 3, K = 1
Output: [2,2,2,4]
Steps:
1. [2,1,2,4]
1. [2,2,2,4]
1. [2,2,2,4] (overflow)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;analysis&#34;&gt;Analysis&lt;/h2&gt;

&lt;p&gt;With these assumptions, this question is a bit complicated than the one in leetcode. We need to explicitly deal with some conditions. For example, instead of overflow, we have high walls on both sides, we don&amp;rsquo;t need to care about whether we will overflow or not.&lt;/p&gt;

&lt;h3 id=&#34;conditions&#34;&gt;Conditions&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;On right side find the 1. right most position, 2. lowest level, 3.water can flow there (water can&amp;rsquo;t flow up)&lt;/li&gt;
&lt;li&gt;Do the same on the left side.&lt;/li&gt;
&lt;li&gt;Check if we overflow: checking the level of the position we find on both left and right sides. One in overflow position and the other is either in overflow position or the level of that position is not lower than dropping position(V), then we will overflow.&lt;/li&gt;
&lt;li&gt;Otherwise, find the correct position, it should be the one on right side, unless the right position is not a &lt;strong&gt;&amp;lsquo;eventually fall&amp;rsquo;&lt;/strong&gt; position while the one on the left is.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;coding&#34;&gt;Coding&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pour_water&lt;/span&gt;(elevation, drop_count, drop_pos):
    n &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; len(elevation)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; range(drop_count):
        right_pos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; drop_pos
        left_pos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; drop_pos

        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; right_pos &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; elevation[right_pos &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; elevation[right_pos]:
            right_pos &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; left_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; elevation[left_pos &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; elevation[left_pos]:
            left_pos &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;

        next_pos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right_pos
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (right_pos &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; left_pos &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) \
                &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; (right_pos &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; n &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; elevation[left_pos] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; elevation[drop_pos]) \
                &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; (left_pos &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; elevation[right_pos] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; elevation[drop_pos]):
            &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;elif&lt;/span&gt; elevation[right_pos] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; elevation[drop_pos] &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; elevation[left_pos] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; elevation[drop_pos]:
            next_pos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left_pos

        elevation[next_pos] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; elevation&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;tips&#34;&gt;Tips&lt;/h3&gt;

&lt;p&gt;When scanning using while loop, we can check the value on next index before moving forward. In this way, our result index will be the last one that satisfy the while condition. Be attention that the first index is not checked.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Create tree from tuples</title>
      <link>https://ericliu03.github.io/posts/2019/04/remove_undirect_edge/</link>
      <pubDate>Sat, 06 Apr 2019 16:55:31 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/remove_undirect_edge/</guid>
      <description>

&lt;p&gt;This is a coding problem from Uber onsite interview found &lt;a href=&#34;https://www.1point3acres.com/bbs/thread-502555-1-1.html&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;question&#34;&gt;Question:&lt;/h3&gt;

&lt;p&gt;Given a list of pairs (tuples), each of them represents a connection from parent to it&amp;rsquo;s child in a tree. In this list, nodes will have edges not only for their direct children, but also all of it&amp;rsquo;s descendants (i.e. children&amp;rsquo;s children, and their children etc).&lt;/p&gt;

&lt;p&gt;If we have the following tree as an example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    A
   / \
  B   C
 / \
 D  E
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the list given it will be&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; [(A,B), (A,D), (A,E), (A,C), (B,D), (B,E)]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can assume the tuples given will result in a valid tree. Use this list to construct a tree.&lt;/p&gt;

&lt;h3 id=&#34;analysis&#34;&gt;Analysis&lt;/h3&gt;

&lt;p&gt;Intuitively, what we want to do is to remove the connections &lt;em&gt;a -&amp;gt; b&lt;/em&gt; while a is not the node&amp;rsquo;s parent in the tree. The way to distinguish those connections is to find out if there&amp;rsquo;s another way to connect a -&amp;gt; b. If there is any, saying a -&amp;gt; a&amp;rsquo; -&amp;gt; b, then we know b&amp;rsquo;s parent is a&amp;rsquo; instead a then we should remove a -&amp;gt; b.&lt;/p&gt;

&lt;p&gt;From a different perspective, if we imagine the tuples in the list are the edges in a directed graph, then we want is a &lt;a href=&#34;https://en.wikipedia.org/wiki/Transitive_reduction&#34;&gt;&lt;strong&gt;transitive reduction&lt;/strong&gt;&lt;/a&gt; of the original graph (represented by all the edges). The transitive reduction of a graph contains &lt;em&gt;the fewest possible edges that has the same reachability relation as the original graph, by discarding the edges u → v for which G also contains a longer path connecting the same two vertices.&lt;/em&gt; In this way, the transitive reduction we generated will be the tree the question asked.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;list given is a &lt;strong&gt;partially ordered set&lt;/strong&gt; of a &lt;a href=&#34;https://en.wikipedia.org/wiki/Directed_acyclic_graph&#34;&gt;&lt;strong&gt;DAG&lt;/strong&gt; (Directed Acyclic Graph)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;You can also find it &lt;a href=&#34;https://algs4.cs.princeton.edu/42digraph/&#34;&gt;here&lt;/a&gt; at item 38 in &lt;em&gt;Web Exercises&lt;/em&gt; section.&lt;/li&gt;
&lt;li&gt;This question is a &lt;strong&gt;tree&lt;/strong&gt; problem, but actually it&amp;rsquo;s asking for a solution that generates the transitive reduction of a &lt;strong&gt;graph&lt;/strong&gt;. It&amp;rsquo;s important to &lt;em&gt;look beyond the surface&lt;/em&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;algorithm&#34;&gt;Algorithm&lt;/h3&gt;

&lt;h4 id=&#34;method-0-dfs&#34;&gt;Method 0: DFS&lt;/h4&gt;

&lt;p&gt;Following the intuitive algorithm, we could loop through every node &lt;strong&gt;u&lt;/strong&gt; in the graph and remove the edges &lt;strong&gt;u-&amp;gt;v&lt;/strong&gt; if there are other paths that connect from &lt;strong&gt;u&lt;/strong&gt; to &lt;strong&gt;v&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; collections

&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;generate_tree0&lt;/span&gt;(edges):

    children &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; collections&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;defaultdict(set)
    nodes &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; set()
    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; u, v &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; edges:
        children[u]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add(v)
        nodes&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add(u)
        nodes&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add(v)

    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;dfs&lt;/span&gt;(start, target):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; start &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; target:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; True
        result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; False
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; next_node &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; children[start]:
            &lt;span style=&#34;color:#75715e&#34;&gt;# in case we have edge that points to a node itself&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; next_node &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; start:
                result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; result &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; dfs(next_node, target)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; result

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; node &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; nodes:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; child &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; list(children[node]):
            found &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; False
            &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; other_child &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; list(children[node]):
                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; other_child &lt;span style=&#34;color:#f92672&#34;&gt;!=&lt;/span&gt; child &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; dfs(other_child, child):
                    found &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; True
                    &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; found:
                children[node]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;remove(child)

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; children&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Complexity:
 If we have N nodes, for each node we have to go to every other nodes in worst case so time complexity should be \( O(N^2) \).&lt;/p&gt;

&lt;h4 id=&#34;method-1-topological-sort&#34;&gt;Method 1: Topological Sort&lt;/h4&gt;

&lt;p&gt;We want to remove the edges that connects u-&amp;gt;v if there are other longer paths. From another perspective, we want to keep the path from &lt;strong&gt;root -&amp;gt; v&lt;/strong&gt; with longest path. From the description we a vertex will have a edge to all of it&amp;rsquo;s decedents, which means a vertex will have all the edges from all of it&amp;rsquo;s ancestors (indegree[v] = len(path_from_root). If we order the edges by the distance in the longest path, then we only keep the closest one. Here we can use &lt;a href=&#34;https://en.wikipedia.org/wiki/Topological_sorting&#34;&gt;Topological sort&lt;/a&gt; to get the order. In the process of sorting, in each round we will have node &lt;strong&gt;u&lt;/strong&gt; that have no edge from others to u (i.e. 0 &lt;a href=&#34;https://en.wikipedia.org/wiki/Directed_graph#Indegree_and_outdegree&#34;&gt;indegree&lt;/a&gt;). For every one of it&amp;rsquo;s neighbors &lt;strong&gt;v&lt;/strong&gt; it connects &lt;em&gt;to&lt;/em&gt;, if there&amp;rsquo;s any other nodes &lt;strong&gt;x&lt;/strong&gt; connects &lt;strong&gt;to&lt;/strong&gt; v, then it means there will be longer path(s) that connects from &lt;strong&gt;u&lt;/strong&gt; to &lt;strong&gt;v&lt;/strong&gt;, then the edge u-&amp;gt;v should be discarded.&lt;/p&gt;

&lt;p&gt;We will use two maps to keep track of the indegrees and outdegrees of a node, and do edits in the process of sorting.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; collections

&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;generate_tree0&lt;/span&gt;(edges):
    indegrees &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; collections&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;defaultdict(int)
    outdegrees &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; collections&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;defaultdict(set)

    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; u, v &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; edges:
        indegrees[v] &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; u &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; indegrees:
            indegrees[u] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
        outdegrees[u]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;add(v)

    queue &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [u &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; u, count &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; indegrees&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;items() &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; indegrees[u] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; queue:
        curr_node &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; queue&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pop(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; neighbor &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; list(outdegrees[curr_node]):
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; indegrees[neighbor] &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:
                queue&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(neighbor)
            &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;:
                indegrees[neighbor] &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
                outdegrees[curr_node]remove(neighbor)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; outdegrees&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Complexity:
 If we have N nodes, for each node we have to go to every other nodes in worst case so time complexity should be \( O(N) \). .&lt;/p&gt;

&lt;h4 id=&#34;other-thoughts-bottom-up&#34;&gt;other thoughts: bottom up&lt;/h4&gt;

&lt;p&gt;Goal is still the same, just this time we check our parent&amp;rsquo;s children. We first pick the nodes with zero-outdegree (i.e leaf nodes) and check one by one. If the a node &lt;strong&gt;v&lt;/strong&gt; is the only child of it&amp;rsquo;s parent &lt;strong&gt;u&lt;/strong&gt;, then we should keep that edge &lt;strong&gt;u-&amp;gt;v&lt;/strong&gt; and remove all other edges that connected to &lt;em&gt;v&lt;/em&gt;. This could be seen as a variation of topological sort.&lt;/p&gt;

&lt;p&gt;However, the problem is that we don&amp;rsquo;t know which parent should we keep. For example, we have a leaf node v and it have parents u1 and u2, then which one should we keep? from the desription above, if we keep the parent that has only one child, then what about the situations that v has a sibling v2? i.e u2 -&amp;gt; v and u2 -&amp;gt; v2, then we should keep u2 as the parent.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Interviews</title>
      <link>https://ericliu03.github.io/posts/2019/04/interviews/</link>
      <pubDate>Fri, 05 Apr 2019 09:20:41 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/interviews/</guid>
      <description>&lt;p&gt;This is actually why (or saying the trigger) I create a website and begin blogging.&lt;/p&gt;

&lt;p&gt;Recently I was preparing for changing job. Inevitably I have to prepare for the coding interviews. It was funny that the recruiters from all of the companies I interviewed with suggests online coding websites to get prepared, and first ones of every list is &lt;a href=&#34;www.leetcode.com&#34;&gt;leetcode.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;During these 3 months in preparing, I was discussing with my teammates/friends about what we want to see from interviews as interviewers. We agreed that the thought process is most important one, and then it&amp;rsquo;s the problem itself, since it&amp;rsquo;s possible to get stuck, or go some circles if you first met this problem. No one will need those and thus and practice on those algorithm problems in daily work.&lt;/p&gt;

&lt;p&gt;But I think I&amp;rsquo;m wrong, or at least not that accurate on the percentage of characteristic they would like to see from you during the interviews. Let&amp;rsquo;s list what areas we should have as a developer:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;thought process: the way you approach a new problem, and how you solve it&lt;/li&gt;
&lt;li&gt;communication: can you make others clear about your thought&lt;/li&gt;
&lt;li&gt;algorithm and data structure: basically CS knowledge&lt;/li&gt;
&lt;li&gt;coding style: naming, methods, spaces&lt;/li&gt;
&lt;li&gt;result correctness:&lt;/li&gt;
&lt;li&gt;tests cases: how do you want to test your program to ensure it&amp;rsquo;s correct&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;I think I put too much weight on 1 and 2 because I thought that&amp;rsquo;s the part that shows how a person works in real world, and whether a person is a good cooperator. But yes, that&amp;rsquo;s my thoughts, or the thoughts from the people I know.&lt;/p&gt;

&lt;p&gt;In a 45 or 60 minute interview, it&amp;rsquo;s hard to express all of the area listed above, which you have to, so how? In my opinion the part I can work on, and improve is the speed of writing coding. &lt;strong&gt;So that I could write code so quickly enough to still keep the time and effort I will use to communicate and explain, to test and walk through the algorithm.&lt;/strong&gt; It&amp;rsquo;s not because it&amp;rsquo;s a mandatory in work (and my friend and I thought it&amp;rsquo;s kind of ridiculous), but it&amp;rsquo;s for the interview to be perfect(无懈可击) (as much as possible) that people won&amp;rsquo;t have something bad to put on their feedbacks.&lt;/p&gt;

&lt;p&gt;Why? because you don&amp;rsquo;t know the interviewers, it&amp;rsquo;s possible some people want perfectness of code, some people think communication and collaboration is the most important thing, while others like to see clean code and meaningful names. The bad thing is that you don&amp;rsquo;t know what they want, so all you can do is give them all.&lt;/p&gt;

&lt;p&gt;This blog comes an action item of my reviews the interview I&amp;rsquo;ve been through. I will keep working on the algorithms as a long lasting background job to write down my journey on this. I will try to dive deep on the algorithms, complexity analysis and do clear explanations.&lt;/p&gt;

&lt;p&gt;You are not guaranteed to succeed, but you are guaranteed not if you don&amp;rsquo;t try. Do my part, and accept the rest.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Create Web</title>
      <link>https://ericliu03.github.io/posts/2019/04/create-web/</link>
      <pubDate>Fri, 05 Apr 2019 09:01:37 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/04/create-web/</guid>
      <description>

&lt;p&gt;This is technically first post in this blog. I thought it&amp;rsquo;s worth to write down the process of creating this static website.&lt;/p&gt;

&lt;p&gt;I choose to use English as the language in this blog, which might be helpful in future. Or I may switch to Chinese anyway.&lt;/p&gt;

&lt;h2 id=&#34;steps&#34;&gt;Steps&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;Searched a little bit in zhihu.com and found this post about &lt;a href=&#34;https://blog.coderzh.com/2015/08/29/hugo/&#34;&gt;create website using huge&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;quick start with hugo: &lt;a href=&#34;https://gohugo.io/getting-started/quick-start/&#34;&gt;https://gohugo.io/getting-started/quick-start/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;and hosting on github: &lt;a href=&#34;https://gohugo.io/hosting-and-deployment/hosting-on-github/&#34;&gt;https://gohugo.io/hosting-and-deployment/hosting-on-github/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;It&amp;rsquo;s quite simple to create a simple page, but there sohuld be more features to add later. Let&amp;rsquo;s see if there&amp;rsquo;s any needed, and add them then.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>My First Post</title>
      <link>https://ericliu03.github.io/posts/my-first-post/</link>
      <pubDate>Fri, 05 Apr 2019 08:31:26 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/my-first-post/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
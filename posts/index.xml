<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Yang&#39;s Blog</title>
    <link>https://ericliu03.github.io/posts/</link>
    <description>Recent content in Posts on Yang&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 10 Jan 2020 21:49:43 -0800</lastBuildDate>
    
	<atom:link href="https://ericliu03.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Leetcode 962] Maximum Width Ramp</title>
      <link>https://ericliu03.github.io/posts/2019/10/lc_962_maximum_width_ramp/</link>
      <pubDate>Fri, 10 Jan 2020 21:49:43 -0800</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/10/lc_962_maximum_width_ramp/</guid>
      <description>Question Leetcode 962. Maximum Width Ramp
Given an array A of integers, a ramp is a tuple (i, j) for which i &amp;lt; j and A[i] &amp;lt;= A[j]. The width of such a ramp is j - i.
Find the maximum width of a ramp in A. If one doesn&amp;rsquo;t exist, return 0.
Note:  2 &amp;lt;= A.length &amp;lt;= 50000 0 &amp;lt;= A[i] &amp;lt;= 50000  Examples: Example 1: Input: [6,0,8,2,1,5] Output: 4 Explanation: The maximum width ramp is achieved at (i, j) = (1, 5): A[1] = 0 and A[5] = 5.</description>
    </item>
    
    <item>
      <title>[Leetcode 955] Delete Columns to Make Sorted II</title>
      <link>https://ericliu03.github.io/posts/2019/10/lc_955_delete_columns_to_make_sorted_ii/</link>
      <pubDate>Wed, 08 Jan 2020 21:24:40 -0800</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/10/lc_955_delete_columns_to_make_sorted_ii/</guid>
      <description>Question 955. Delete Columns to Make Sorted II
We are given an array A of N lowercase letter strings, all of the same length.
Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices.
For example, if we have an array A = [&amp;quot;abcdef&amp;quot;,&amp;quot;uvwxyz&amp;quot;] and deletion indices {0, 2, 3}, then the final array after deletions is [&amp;quot;bef&amp;quot;,&amp;quot;vyz&amp;quot;].</description>
    </item>
    
    <item>
      <title>[Leetcode 1124] Longest Well Performing Interval</title>
      <link>https://ericliu03.github.io/posts/2019/10/lc_1124_longest_well_performing_interval/</link>
      <pubDate>Mon, 06 Jan 2020 21:34:46 -0800</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/10/lc_1124_longest_well_performing_interval/</guid>
      <description>Question Leetcode 1124. Longest Well-Performing Interval
We are given hours, a list of the number of hours worked per day for a given employee.
A day is considered to be a tiring day if and only if the number of hours worked is (strictly) greater than 8.
A well-performing interval is an interval of days for which the number of tiring days is strictly larger than the number of non-tiring days.</description>
    </item>
    
    <item>
      <title>[Leetcode 329] Longest Increasing Path in a Matrix</title>
      <link>https://ericliu03.github.io/posts/2019/10/lc_329_longest_increasing_path_in_a_matrix/</link>
      <pubDate>Tue, 29 Oct 2019 14:36:47 -0800</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/10/lc_329_longest_increasing_path_in_a_matrix/</guid>
      <description>Question Leetcode 329: Longest Increasing Path in a Matrix
Given an integer matrix, find the length of the longest increasing path.
From each cell, you can either move to four directions: left, right, up or down. You may NOT move diagonally or move outside of the boundary (i.e. wrap-around is not allowed).
Examples: Example 1: Input: nums = [ [9,9,4], [6,6,8], [2,1,1] ] Output: 4 Explanation: The longest increasing path is [1, 2, 6, 9].</description>
    </item>
    
    <item>
      <title>[Leetcode 678] Valid Parenthesis String</title>
      <link>https://ericliu03.github.io/posts/2019/10/lc_678_valid_parenthesis_string/</link>
      <pubDate>Fri, 25 Oct 2019 11:34:38 -0700</pubDate>
      
      <guid>https://ericliu03.github.io/posts/2019/10/lc_678_valid_parenthesis_string/</guid>
      <description>Question Leetcode 678: Valid Parenthesis String
Given a string containing only three types of characters: &#39;(&#39;, &#39;)&#39; and &#39;*&#39;, write a function to check whether this string is valid. We define the validity of a string by these rules:
 Any left parenthesis &#39;(&#39; must have a corresponding right parenthesis &#39;)&#39;. Any right parenthesis &#39;)&#39; must have a corresponding left parenthesis &#39;(&#39;. Left parenthesis &#39;(&#39; must go before the corresponding right parenthesis &#39;)&#39;.</description>
    </item>
    
  </channel>
</rss>